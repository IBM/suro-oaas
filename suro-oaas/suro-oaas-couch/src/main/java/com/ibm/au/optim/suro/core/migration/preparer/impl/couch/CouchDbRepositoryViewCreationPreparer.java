package com.ibm.au.optim.suro.core.migration.preparer.impl.couch;


import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.ibm.au.optim.suro.model.store.impl.couch.*;
import com.ibm.au.jaws.web.core.runtime.Environment;

import org.ektorp.CouchDbConnector;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.io.InputStream;

/**
 * Class <b>CouchDbRepositoryViewCreationPreparer</b>. This class extends {@link CouchDbViewCreationPreparer} and 
 * creates the views necessary to operate the system. The preparer will attempt to access all the views and if an
 * exception is thrown add the view to the list of missing views. If the list of missing views is not empty, the
 * preparer will attempt to create them directly.
 *
 * @author Peter Ilfrich, Christian Vecchiola
 */
public class CouchDbRepositoryViewCreationPreparer extends CouchDbViewCreationPreparer {
	
	/**
	 * A {@link String} representing the path to the resource file that contains the information about the
	 * updated definition of the views.
	 */
	private static final String VIEW_RESOURCE_FILE = "schemas/views.json";
	
	/**
	 * A {@link Logger} instance that collects all the messages generated by instances of this class.
	 */
	private static final Logger LOGGER = LoggerFactory.getLogger(CouchDbRepositoryViewCreationPreparer.class);

    
    /**
     * This method retrieves the {@link CouchDbConnector} instance that is required to check whether the views are updated. The
     * The method first checks whether <i>env</i> has an attribute that is mapped by the value of {@link CouchDbRepositoryViewUpdate#getRepoInstance()}. 
     * If an instance mapping the attribute is found, it then checks that implements first the interface type that is specified by 
     * {@link CouchDbRepositoryViewUpdate#getRepoType()} and then the type that is specified by the method {@link CouchDbRepositoryViewUpdate#getRepoInstance()}. 
     * If both the two checks  are successful, it is expected that the selected repository implementation is of type {@link AbstractCouchdbRepository} and 
     * therefore the related {@link CouchDbConnector} instance is returned. 
     * 
     * @param viewUpdate	an instance of {@link CouchDbViewUpdate} that contains the information about the view to be checked.
     * 						This is expected to be an instance of {@link CouchDbRepositoryViewUpdate}.
     * @param env			an instance of {@link Environment} that contains the configuration and shared components of the application.
     * 
     * @return	a {@link CouchDbConnector} instance that can be used to establish a connection to the <i>CouchDb</i> instance that
     * 			stores the view information for <i>viewUpdate</i>, or {@literal null} if not found.
     */
	@Override
    protected CouchDbConnector getConnector(CouchDbViewUpdate viewUpdate, Environment env) {

    	CouchDbConnector connector = null;
    	CouchDbRepositoryViewUpdate repoViewUpdate = (CouchDbRepositoryViewUpdate)viewUpdate;
    	
    	
    	String interfaceTypeName = repoViewUpdate.getRepoType();
    	String concreteTypeName = repoViewUpdate.getRepoInstance();
    	String attributeName = repoViewUpdate.getRepoAttribute();
    	String viewName = repoViewUpdate.getDocName();
    	
    	try {
    	
	    	Class<?> interfaceType = Class.forName(interfaceTypeName);
	    	Class<?> concreteType = Class.forName(concreteTypeName);
	    	
			Object repo = env.getAttribute(attributeName);
	    	if (repo != null) {
	    		
	    		if (interfaceType.isInstance(repo) == true) {
	    		
		    		if (concreteType.isInstance(repo) == true) {
		    		
						AbstractCouchDbRepository<?,?> updatableRepo = (AbstractCouchDbRepository<?,?>) repo;
						
						connector = updatableRepo.getConnector();
						
		    			
	
		    		} else {
		    			
		    			// we might not need to add the view because
		    			// perhaps the implementation is based on a
		    			// different
		    			
		    			LOGGER.warn("Repository '" + interfaceType.getSimpleName() + "' is not implemented by '" + concreteType.getSimpleName() + "', skipping.");
		    		}
		    		
	    		} else {
	    			
	    			// ok there is something strange here, we expect the
	    			// attribute to map an instance implementing the defined
	    			// interface type.
	    			
	    			LOGGER.error("Attribute '" + attributeName + "' does not implement expected interface type '" + interfaceType.getSimpleName() + "', skipping.");
	    		}
	    		
	    	} else {
	    		
	    		// here we should throw an exception because the system
	    		// cannot continue without this component.
	    		
	    		LOGGER.error("There is no repository instance mapped by the attribute: '" + attributeName + "'.");
	    	}
    	
    	} catch(ClassNotFoundException ex) {
    		
    		LOGGER.error("Cannot retrieve type information required to perform view check [viewName " + viewName + ", interface: " + interfaceTypeName + ", type: " + concreteTypeName + "].", ex);
    	}
    	
    	return connector;
    	
    }

    /**
     * This method retrieves the information about the local and updated views from the resource file of the
     * module. It converts it into a collection of {@link CouchDbRepositoryViewUpdate} instances that will be 
     * used to manage the verification and the update of the views in the <i>CouchDb</i> instances that are 
     * backing the repositories used in the application.
     * 
     * @return	an array of {@link CouchDbRepositoryViewUpdate} containing the definition of the views that 
     * 			are used by the module to access the data. If {@literal null} the information could not be
     * 			retrieved.
     */
	@Override
	protected CouchDbViewUpdate[] getViews()  {
		
		CouchDbViewUpdate[] views = null;
		
		InputStream input = this.getClass().getClassLoader().getResourceAsStream(CouchDbRepositoryViewCreationPreparer.VIEW_RESOURCE_FILE);
       
        if (input != null) {
        	
        
        	try {
        	
        		ObjectMapper mapper = new ObjectMapper();
        		JavaType type = mapper.getTypeFactory().constructArrayType(CouchDbRepositoryViewUpdate.class);
        		CouchDbRepositoryViewUpdate[] array = mapper.readValue(input, type);
        		
        		// we copy within an array of the proper type, even though
        		// java does not complain. The reason for this is because
        		// the views could also be assigned and the super type will
        		// not be a valid assignment to the array that we deserialised.
        		//
        		views = new CouchDbViewUpdate[array.length];
        		for(int v=0; v<views.length; v++) {
        			views[v] = array[v];
        		}
        		
        	} catch(IOException ioex) {
        		
        		LOGGER.error("Could not deserialize view information from the resource file.", ioex);
        		
        	} finally {
        		
        		try {
        		
        			input.close();
        		
        		} catch(IOException ioex) {
        			
        			LOGGER.error("Could not close the stream of the resource file.", ioex);
        			
        		}
        	}
        }
        
        

		return views;
	}
}
