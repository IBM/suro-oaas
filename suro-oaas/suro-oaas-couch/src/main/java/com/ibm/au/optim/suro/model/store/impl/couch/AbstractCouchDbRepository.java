/**
 * Copyright (C) 2015 IBM Corporation
 * All Rights Reserved
 */
package com.ibm.au.optim.suro.model.store.impl.couch;


import com.ibm.au.optim.suro.couch.CouchDbConnectionManager;
import com.ibm.au.optim.suro.couch.CouchDbConnectionMetadata;
import com.ibm.au.optim.suro.model.entities.Entity;
import com.ibm.au.optim.suro.model.entities.couch.CouchDbDocument;
import com.ibm.au.optim.suro.model.entities.Attachment;
import com.ibm.au.optim.suro.model.impl.AbstractSuroService;
import com.ibm.au.optim.suro.model.store.Repository;
import com.ibm.au.jaws.web.core.runtime.Environment;
import org.ektorp.*;
import org.ektorp.support.CouchDbRepositorySupport;
import org.ektorp.support.GenerateView;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * Class <b>AbstractCouchDbRepository</b>. This class extends {@link AbstractSuroService} and implements the
 * {@link Repository} interface. It aggregates the common logic of initialising the connection to a <i>CouchDb</i>
 * instance.
 *
 * @author Christian Vecchiola
 */
public abstract class AbstractCouchDbRepository<Z extends CouchDbDocument<T>, T extends Entity> extends AbstractSuroService implements Repository<T> {


    /**
     * A {@link Logger} instance that can be used to record all the activities generated by
     * the instances of this class.
     */
    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractCouchDbRepository.class);

    /**
     * Class <b>CouchDbProxy</b>. This class extends {@link CouchDbRepositorySupport} and provides
     * a simple extension to use the methods of {@link CouchDbRepositorySupport} with the type that
     * will specialise instances of the outer class.
     *
     * @param <Y>
     * @author Christian Vecchiola
     */
    protected class CouchDbProxy<Y extends CouchDbDocument<T>> extends CouchDbRepositorySupport<Y> {

        /**
         * A {@link Class} instance that keeps track of the type that
         * specialize this generic class.
         */
        protected Class<Y> theType;

        /**
         * Initializes an instance of {@link CouchDbProxy} with the given
         * connection and type information.
         *
         * @param type a {@link Class} instance containing the type
         *             information about the type that specializes
         *             the instances of this generic class. It cannot
         *             be {@literal null}.
         * @param db   a {@link CouchDbConnector} implementation that
         *             provides connection to a <i>CouchDb</i> database.
         */
        public CouchDbProxy(Class<Y> type, CouchDbConnector db) {
            super(type, db);
            this.theType = type;
            this.initStandardDesignDocument();
        }

        /**
         * Gets the list of all the documents contained in the database, which
         * match the type that has been configured for this instance.
         *
         * @return a {@link List} implementation that contains the documents
         * in <i>CouchDb</i> that match the type configured with this
         * instance.
         */
        @GenerateView
        @Override
        public List<Y> getAll() {
            ViewQuery vq = createQuery("all").includeDocs(true).descending(true);
            return db.queryView(vq, this.theType);
        }

        /**
         * Removes all the documents contained in the database, which match the
         * type that has been configured for this instance.
         */
        public void removeAll() {
            for (Y item : getAll()) {
                this.remove(item);
            }
        }

        /**
         * Gets the document that matches the given identifier.
         *
         * @param id a {@link String} representing the unique identifier of the
         *           document to retrieve. It is assumed to not to be {@literal
         *           null}.
         * @return the item matching the given <i>id</i> or {@literal null}.
         */
        public Y getItem(String id) {
            return this.db.get(this.theType, id);
        }

        /**
         * Returns the connection to the database that has been used by the
         * proxy.
         *
         * @return a {@link CouchDbConnector} implementation, which represents
         * the database connection configured with the instance.
         */
        public CouchDbConnector getDb() {
            return this.db;
        }

        /**
         * Returns the list of documents that match the given view.
         *
         * @param viewId a {@link String} representing the identifier of the view.
         * @param id     a {@link String} representing the unique key.
         * @return a {@link List} of documents that is retrieved by executing the
         * query defined by the view.
         */
        public List<Y> getView(String viewId, String id) {
            return queryView(viewId, id);
        }

			  /**
         * Returns the list of documents that match the given view.
         *
         * @param viewId a {@link String} representing the identifier of the view.
         * @param keys a list of values representing a unique complex key
         * @return a {@link List} of documents that is retrieved by executing the
         * query defined by the view.
         */
        public List<Y> getView(String viewId, Object... keys) {
            return queryView(viewId, ComplexKey.of(keys));
        }

        /**
         * Returns the list of documents that match the given view.
         *
         * @param viewId a {@link String} representing the identifier of the view.
         * @return a {@link List} of documents that is retrieved by executing the
         * query defined by the view.
         */
        public List<Y> getView(String viewId) {
            return queryView(viewId);
        }

			  /**
         * Returns the list of documents that match the given view.
         *
         * @param viewId a {@link String} representing the identifier of the view.
         * @param startKey an object representing the start key for a range search
         * @param endKey an object representing the end key for a range search
         * @return a {@link List} of documents that is retrieved by executing the
         * query defined by the view.
         */
        public List<Y> getViewWithRange(String viewId, Object startKey, Object endKey) {
            return db.queryView(createQuery(viewId)
                            .includeDocs(true)
                            .startKey(startKey)
                            .endKey(endKey),
                    type);
        }
    }


    /**
     * A {@link Class} instance containing the type information about the
     * concrete type that has been used to specialize this generic type.
     */
    protected Class<Z> theType;

    /**
     * An instance of {@link CouchDbProxy} that has been configured to retrieve
     * and manage document of the type configured with the specialized implementation
     * of this generic type.
     */
    protected CouchDbProxy<Z> proxy;

    /**
     * An instance of {@link CouchDbConnectionMetadata} that is used to store the
     * connection information used to retrieve an instance of {@link CouchDbConnector}
     * to interact with the selected <i>CouchDb</i> database.
     */
    protected CouchDbConnectionMetadata metadata;
    
    /**
     * A {@link Environment} implementation that provides access to the configuration
     * parameters of the application and the shared components.
     */
    protected Environment environment;

    /**
     * Initializes an instance of {@link AbstractCouchDbRepository} with the given
     * type information.
     *
     * @param theType a {@link Class} instance containing the type information about the
     *                concrete type that has been used to specialize this generic type.
     *                It cannot be {@literal null}.
     * @throws IllegalArgumentException if <i>theType</i> is {@literal null}.
     */
    protected AbstractCouchDbRepository(Class<Z> theType) {
        if (theType == null) {
            throw new IllegalArgumentException("Parameter 'theType' cannot be null.");
        }
        this.theType = theType;
    }


    /**
     * Returns the collection of documents that are in the repository.
     *
     * @return a {@link List} implementation that contains the collection of instances
     * stored in the repository.
     */
    @Override
    public List<T> getAll() {

        List<Z> items = this.proxy.getAll();
        List<T> casted = new ArrayList<>();
        for (Z item : items) {
        	
			T content = (T) item.getContent();
            content.setId(item.getId());
            content.setRevision(item.getRevision());
            
            List<Attachment> attachments = this.getStoreAttachments(item.getAttachments());
            
            content.setAttachments(attachments);
            
            casted.add(content);
        }
        return casted;
    }

    /**
     * Returns the documents that corresponds to the given <i>id</i>.
     *
     * @param id a {@link String} representing the unique identifier of the item.
     *           It cannot be {@literal null}.
     * @return the instance that corresponds to <i>id</i> if found, {@literal null}
     * otherwise.
     * @throws IllegalArgumentException if <i>id</i> is {@literal null}.
     */
    @Override
    public T getItem(String id) {
        
    	if (id == null) {
            throw new IllegalArgumentException("Parameter 'id' cannot be null.");
        }

        Z doc = this.proxy.getItem(id);
		T result = doc.getContent();
        
        result.setId(doc.getId());
        result.setRevision(doc.getRevision());
        
        List<Attachment> attachments = this.getStoreAttachments(doc.getAttachments());
        result.setAttachments(attachments);
        
        return result;
    }

    /**
     * Adds the given item to the repository.
     *
     * @param item the item to add. It cannot be {@literal null}.
     * @throws IllegalArgumentException if <i>item</i> is {@literal null}.
     */
	public void addItem(T item) {
        if (item == null) {
            throw new IllegalArgumentException("Parameter 'item' cannot be null.");
        }

        try {
        	
            Z doc = this.theType.newInstance();
            doc.setContent(item);
            
            this.addItem(doc);
            
        } catch (ReflectiveOperationException e) {
        	
            LOGGER.error("Error instantiating object of type " + this.theType.toString(), e);
        }
    }


    /**
     * Updates the given item to the repository.
     *
     * @param item the item to update. It cannot be {@literal null}.
     * @throws IllegalArgumentException if <i>item</i> is {@literal null}.
     */
	@Override
    public void updateItem(T item) {
        if (item == null || item.getId() == null || item.getRevision() == null) {
            throw new IllegalArgumentException("Parameter 'item', and properties 'item:id', 'item:revision' cannot be null.");
        }
        try {
            Z existing = this.proxy.getItem(item.getId());
            if (existing.getRevision().equals(item.getRevision())) {
                existing.setContent(item);
                this.proxy.update(existing);
                item.setRevision(existing.getRevision());
            } else {
                LOGGER.error("Error updating document " + item.getRevision() + " vs. " + existing.getRevision() + " in the database.");
                throw new UpdateConflictException(existing.getId(), existing.getRevision());
            }
        } catch (UpdateConflictException updateEx) {
            LOGGER.error("[CouchDB]: Updating document causes an exception (" + item.getClass().getName() + ")", updateEx);
        }
    }

    /**
     * Removes all the documents from the repository.
     */
    @Override
    public void removeAll() {
        this.proxy.removeAll();
    }

    /**
     * Removes the given item from the repository.
     *
     * @param id the id of the item to remove. It cannot be {@literal null}.
     * @throws IllegalArgumentException if <i>item</i> is {@literal null}.
     */
    @Override
    public void removeItem(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter 'id' cannot be null.");
        }
        Z item = this.proxy.get(id);
        if (item != null) {
            this.proxy.remove(item);
        }
    }

    @Override
    public List<Attachment> getAttachments(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter 'id' cannot be null.");
        }

        Z doc = this.proxy.getItem(id);
        return getStoreAttachments(doc.getAttachments());
    }

    /**
     * This method returns the underlying connection that is used to communicate
     * with the remote CouchDB instance. This client can be used to perform low
     * level operations with the database.
     *
     * @return	an instance of {@link CouchDbConnector}. This instance is retrieved
     * 			from the underlying proxy and then invoking {@link CouchDbProxy#getDb()}.
     */
    public CouchDbConnector getConnector() {

    	return this.proxy.getDb();
    }

    /**
     * This is the callback that specializes the behaviour of the {@link com.ibm.au.jaws.web.core.runtime.impl.AbstractRuntimeService}
     * instance for binding with <i>CouchDb</i> based repository. The method retrieves the connection
     * parameters from the {@link Environment} implementation and initialize the internal components
     * required to access <i>CouchDb</i>.
     *
     * @param environment an {@link Environment} implementation that provides access to the collection
     *                    of configuration parameters that are set for the web application.
     */
    @Override
    protected void doBind(Environment environment) {
    	
        try {
        	
            String url = environment.getParameter(CouchDbConnectionMetadata.COUCHDB_URL, null);
            if (url == null || url.isEmpty()) {
                LOGGER.warn("No CouchDB connection setting present, defaulting to localhost");
                url = CouchDbConnectionMetadata.COUCHDB_DEFAULT_URL;
            }

            String username = environment.getParameter(CouchDbConnectionMetadata.COUCHDB_USERNAME, null);
            String password = environment.getParameter(CouchDbConnectionMetadata.COUCHDB_PASSWORD, null);
            String database = environment.getParameter(CouchDbConnectionMetadata.COUCHDB_DATABASE, null);

            this.metadata = new CouchDbConnectionMetadata(url, database, username, password);
            CouchDbConnector connector = CouchDbConnectionManager.getInstance(this.metadata);
            this.proxy = new CouchDbProxy<Z>(this.theType, connector);
            
            this.environment = environment;

        } catch (Exception ex) {
        	
            throw new RuntimeException("Could not initialize the repository.", ex);
        }
    }

    /**
     * Releases the connector instance that was previously acquired.
     */
    @Override
    protected void doRelease() {

        this.proxy = null;
        this.environment = null;

        // [CV] NOTE: we should release all the connections, this is an improvement.
        //
        // CouchDbConnectionManager.releaseInstance(this.metadata);
    }


    /**
     * Adds an item to the repository. The method will make sure that the meta information of the item is copied into
     * the bean object as well.
     * @param item - the couch db document
     */
    protected void addItem(Z item) {
    	
        this.proxy.add(item);
        
        item.getContent().setId(item.getId());
        item.getContent().setRevision(item.getRevision());
        item.getContent().setAttachments(this.getStoreAttachments(item.getAttachments()));
    }


    /**
     * Retrieves the content (the bean object / {@link StoreObject}) from a couchdb document. By doing so it will also
     * set the meta information (id, revision, attachments) of the store object.
     * @param item - the couchdb document
     * @return
     */
    protected T getContent(Z item) {
    	
		T content = (T) item.getContent();
        
        content.setId(item.getId());
        content.setRevision(item.getRevision());
        
        List<Attachment> attachments = this.getStoreAttachments(item.getAttachments());
        content.setAttachments(attachments);
        
        return content;
    }


    /**
     * Converts the passed map of CouchDb attachments into a map of StoreAttachments (containing the meta information of
     * an attachment, same interface used for the transient repositories.
     * @param attachments - a map from file name to couch db attachment
     * @return - a map from file name to store attachment (meta information)
     */
    protected List<Attachment> getStoreAttachments(Map<String, org.ektorp.Attachment> attachments) {
        if (attachments == null) {
            return null;
        }

        // init result
        List<Attachment> result = new ArrayList<Attachment>();

        // convert each entry
        for (Map.Entry<String, org.ektorp.Attachment> pair : attachments.entrySet()) {
        	
            org.ektorp.Attachment att = pair.getValue();
            // extract meta information
            Attachment sa = new Attachment(pair.getKey(), att.getContentLength(), att.getContentType());
            // store in result
            result.add(sa);
        }

        // don't return an empty map
        if (result.isEmpty()) {
        	
            return null;
            
        } else {
        	
            return result;
        }
    }


}



