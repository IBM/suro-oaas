/**
 * 
 */
package com.ibm.au.optim.suro.core.migration.preparer.impl.couch;

import java.io.InputStream;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.ektorp.CouchDbConnector;
import org.ektorp.http.HttpClient;
import org.ektorp.http.HttpResponse;
import org.ektorp.support.DesignDocument;
import org.ektorp.support.DesignDocument.View;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

/**
 * Class <b>ViewUpdate</b>. This is an helper class that is used to synchronise the definition of the views
 * from version to version. This class embeds the logic that is used to retrieve the definition of the views
 * check against the local definition and update those views if needed.
 * 
 * @author Christian Vecchiola.
 *
 */
@JsonIgnoreProperties({ "client", "viewDocument", "isViewNeedingUpdate", "isViewUpdated" })
public class CouchDbViewUpdate {
	
	/**
	 * A {@link String} representing the prefix that is used to identify design document.
	 */
	private static final String DESIGN_PREFIX = "_design/";
	
	/**
	 * A {@link Logger} instance that collects all the messages generated by instances of this class.
	 */
	private static final Logger LOGGER = LoggerFactory.getLogger(CouchDbViewUpdate.class);
	
	/**
	 * A {@link String} representing the name of the design document that will contain the definition 
	 * of the views, without the <i>_design/</i> prefix. This information is used to compose the URL 
	 * of the design document.
	 */
	private String docName;
	/**
	 * A {@link Map} implementation that is used to store the definition of the views, where the key 
	 * represents the name of the view and the value definition of the map function that is required
	 * to execute the view.
	 */
	private Map<String, View> views;

	
	/**
	 * A {@link Map} implementation that contains the information about the view that are currently
	 * saved and defined in the <i>CouchDb</i> instance.
	 */
	protected DesignDocument viewDocument;
	
	/**
	 * A {@link CouchDbConnector} implementation that is used to interact with the CouchDb instance. The
	 * client enables the class to perform those low-level operations that are required to setup the
	 * views.
	 */
	protected CouchDbConnector connector;
	
	/**
	 * An internal {@literal boolean} flag indicating whether the collection of views that are
	 * managed by this instance needs to be updated in the <i>CouchDb</i> instance that is 
	 * configured with the instance.
	 */
	protected boolean isViewNeedingUpdate = false;
	
	/**
	 * An internal {@literal boolean} flag indicating whether the collection of views that are
	 * managed by this insyance has been updated in the <i>CouchDb</i> instance that is configured
	 * with the instance.
	 */
	protected boolean isViewUpdated = false;
	
	/**
	 * A {@link String} containing the uri that is used to retrieve the design document
	 * containing the view definitions that this instance is managing.
	 */
	protected String viewUri = null;
	
	/**
	 * Initialises an instance of the {@link CouchDbViewUpdate} class.
	 */
	public CouchDbViewUpdate() {
		
	}
	
	/**
	 * Initialises an instance of the {@link CouchDbViewUpdate} class. With the given name and collection
	 * of views.
	 * 
	 * @param docName		a {@link String} representing the name of the type for which the views
	 * 						are being created.
	 * @param views			a {@link Map} implementation that represents the collection of views that
	 * 						are defined in the view document identified by the given <i>viewName</i>.
	 * 
	 * @throws IllegalArgumentException	if <i>docName</i> is {@literal null} or an empty string.
	 */
	public CouchDbViewUpdate(String docName, Map<String,View> views) {
		
		this.setDocName(docName);
		this.setViews(views);
	}
	
	/**
	 * Configures the instance of {@link CouchDbConnector} that will be used by the {@link CouchDbViewUpdate} to
	 * check whether the views need to be updated.
	 * 
	 * @param connector	a {@link CouchDbConnector} instance that provides the connection to the CouchDb instance.
	 */
	public void setConnector(CouchDbConnector connector) {
		
		this.connector = connector;
		this.viewUri = null;
	}
	
	/**
	 * Sets the partial name of the design document that will contain the definition of the views..
	 * 
	 * 
	 * @param docName	a {@link String} representing the name of the view document. It cannot be 
	 * 					{@literal null} or an empty string. The value of the name is without the
	 * 					<i>_design/</i> prefix, which is automatically added.
	 * 
	 * @throws IllegalArgumentException	if <i>typeName</i> is {@literal null} or an empty string.
	 */
	public void setDocName(String docName) {
		
		if ((docName == null) || (docName.isEmpty() == true)) {
			
			throw new IllegalArgumentException("Parameter 'docName' cannot be null or an empty string.");
		}
		this.docName = docName;
		this.viewUri = null;
	}
	
	/**
	 * Gets the partial name of the design document that contains the definition of the views. It 
	 * cannot be {@literal null} or an empty string.
	 * 
	 * @return	a {@link String} representing the name of the view document without the <i>_design/</i> prefix.
	 */
	public String getDocName() {
		
		return this.docName;
	}
	
	/**
	 * Sets the collection of view functions that are associated to the design document
	 * managed by this instance.
	 * 
	 * @param views	a {@link Map} implementation whose key represents the name of the view functions
	 * 				and corresponding values the definition of the functions.
	 */
	public void setViews(Map<String, View> views) {

		this.views = views;
		
	}
	/**
	 * Gets the collection of view definition that correspond to the view document. These are the ones that
	 * will be used to check whether the definition of the view in the <i>CouchDb</i> instance are updated.
	 * 
	 * @return	a {@link Map} implementation where the keys represent the name of the view and the value
	 * 			their corresponding implementation (as a javascript text).
	 */
	public Map<String, View> getViews() {
		
		return this.views;
	}

	/**
	 * Gets the client that is used to interact with the <i>CouchDb<i> instance.
	 * 
	 * @return	a {@link HttpClient} implementation configured to connect to the related <i>CouchDb</i> instance.
	 * 			It can be {@literal null} if the instance does not need to operate.
	 */
	public CouchDbConnector getConnector() {
		
		return this.connector;
	}
	
	/**
	 * This method checks whether the <i>CouchDb</i> instance needs to be updated with the view definition. The
	 * method first checks whether the corresponding view document exists in the <i>CouchDb<i> instance and if
	 * it exists it verifies that all the local views that are configured with this instance of <i>ViewUpdate</i>
	 * are matched and present in the <i>CouchDb</i> instance.
	 * 
	 * @return	{@literal true} if any of the view defined in this instance of {@link CouchDbViewUpdate} is missing or
	 * 			does not match the definition found in the <i>CouchDb<i> instance. {@literal false} otherwise.
	 */
	public boolean checkForUpdates() {
		
		this.isViewNeedingUpdate = false;
		
		// 1. check first that the connection is available otherwise
		//    there is something wrong.
		
		if (this.connector != null) {
		
			// 2. make a GET request to the view document to check whether
			//    it exists
			
			String uri = this.composeUri();
			
			HttpClient client = this.connector.getConnection();
			
			HttpResponse response = client.get(uri);
			
			int code = response.getCode();
			if (code == 200) {
				
				// 3. if exists download the content of the views and check whether the text of the view function is the
				//    the same as the one that we have locally if not it needs update.
				
				InputStream body = response.getContent();
				
				ObjectMapper mapper = new ObjectMapper();
				
				try {
				
					this.viewDocument = mapper.readValue(body, DesignDocument.class);
					
					int currentNumberOfViews = this.viewDocument.getViews().size();
					
					
					for(Entry<String,View> view : views.entrySet()) {
						
						String vName = view.getKey();
						
						View currentView = this.viewDocument.get(vName);
						if (currentView == null) {
							
							this.isViewNeedingUpdate = true;
							
							this.viewDocument.addView(vName, view.getValue());
							
						} else {
							
							currentNumberOfViews =- 1;
							

							View newView = view.getValue();
							
							// in this case we need to check whether the
							// value of the map function is the same.
							
							// 1. check the map function
							//
							String currentFunction = currentView.getMap();
							String newFunction = newView.getMap();
							boolean areTheSame = this.areTheSame(currentFunction, newFunction);
							
							if (!areTheSame) {
								
								this.isViewNeedingUpdate = true;
								currentView.setMap(newFunction);
								this.viewDocument.addView(vName, currentView);
							}
							
							// 2. check the reduce function
							//
							currentFunction = currentView.getReduce();
							newFunction = newView.getReduce();
							areTheSame = this.areTheSame(currentFunction, newFunction);
							
							if (!areTheSame) {
								this.isViewNeedingUpdate = true;
								currentView.setReduce(newFunction);
								this.viewDocument.addView(vName, currentView);
							}
						}
					}
					
					if (currentNumberOfViews > 0) {
						
						// ok we do have a number of left over views that were not
						// defined in the current set, we will delete them because
						// all the views 
						
						String id = this.viewDocument.getId();
						
						LOGGER.warn("There are " + currentNumberOfViews + " that were not declared for " + id  + ". These are:");
						
						
						Set<String> declared = views.keySet();
						Set<String> found = this.viewDocument.getViews().keySet();
						
						for(String v : found) {
							
							if (declared.contains(v) == false) {
								
								LOGGER.warn(id + "/views/" + v);
							}
						}
					}
					
				
				} catch(Exception ex) {
					
					LOGGER.error("An error occurred, while reading the view document: " + uri, ex);
				}
				
			} else if (code == 404) {
				
				// 4. if not exists, then checks whether the list of local views is not empty, and if so, it needs update
				
				this.isViewNeedingUpdate = (this.views != null) && (this.views.size() > 0);
				
				if (this.isViewNeedingUpdate) {
					
					this.viewDocument = new DesignDocument();
					this.viewDocument.setId(CouchDbViewUpdate.DESIGN_PREFIX + this.docName);
					
					for(Entry<String,View> view : views.entrySet()) {
						
						this.viewDocument.addView(view.getKey(), view.getValue());
					}
				}
				
			} else {

				LOGGER.error("An error occurred while trying to retrieve the view document (HTTP Status code: " + code + ").");
			}
		
		} else {
			
			// ok we can just log the fact that the 
			
			LOGGER.warn("Method needsUpdate called when client is not configured - skipping.");
			
		}
			
		return this.isViewNeedingUpdate;
	}
	

	/**
	 * This method performs the update. It merges the definition of views that are required by this module
	 * with the definition of the views that are found in the <i>CouchDb</i> instance, by overriding any
	 * definition in the database with the local definition. The method then submits the new design document
	 * to the database.
	 */
	public void update() {
		
		// checks whether the operations needs to be updated and if so
		// create a merge of the two documents (remote and local) and
		// push the changes.
		
		if (this.isViewNeedingUpdate) {
			
			if (this.connector != null) {
				
				String uri = this.composeUri();
				
				if (this.viewDocument != null) {
				
					ObjectMapper mapper = new ObjectMapper();
					
					HttpClient client = this.connector.getConnection();
					
					try {
						
						String updatedDocument = mapper.writeValueAsString(this.viewDocument);
						HttpResponse response = client.put(uri, updatedDocument);
						//int code = response.getCode();
						this.isViewUpdated = response.isSuccessful();
						
					} catch (JsonProcessingException e) {
						
						LOGGER.error("Could not serialize into JSON the view document.", e);
					}
				
				} else {
					
					throw new IllegalStateException("The view document is null, we do not need to perform any update.");
				}
				
			} else {

				throw new IllegalStateException("Cannot update the view with no client configured.");
			}
			
			
		} else {
			
			
			LOGGER.warn("The view does not need update, skipping.");
		}
		
	}
	/**
	 * Validates the update operation.
	 * 
	 * @return	{@literal true} if the <i>CouchDb<i> instance did not need update or if it did need update
	 * 			and the update operation has been successful. {@literal false} otherwise.
	 */
	public boolean isUpdated() {
		
		// returns the update flag if everything is successful.
		return this.isViewUpdated;
		
	}
	/**
	 * Provides information about whether the view needs to be updated. This method does not implement
	 * any check, but simply reports the result of a check previously executed.
	 * 
	 * @return	{@literal true} if there is a need for an update, {@literal false} if not.
	 */
	public boolean needsUpdate() {
		
		return this.isViewNeedingUpdate;
	}
	
	/**
	 * Gets the uri that corresponds to the design document that contains the views.
	 * 
	 * @return	a {@link String} representing the relative url to the database of the 
	 * 			design document that contains the collection of views.
	 */
	private String composeUri() {
		
		if (this.viewUri == null) {
			
			this.viewUri = this.connector.path() + "_design/" + this.docName;
		}
		
		return this.viewUri;
	}
	
	/**
	 * This function compare the two given function texts and checks whether they are
	 * equal or both {@literal null}. In both these two cases it returns {@literal true},
	 * otherwise it returns {@literal false}.
	 * 
	 * @param currentFunction	a {@link String} representing the current view function stored
	 * 							in the <i>CouchDbInstance</i>. It can be {@literal null}.
	 * @param newFunction		a {@link String} representing the updated view function that
	 * 							needs to be compared against the current function. It can be
	 * 							{@literal null}.
	 * 
	 * @return	{@literal true} if the body of the two functions are the same, or both of the
	 * 			two are {@literal null}, {@literal false} otherwise.
	 */
	private boolean areTheSame(String currentFunction, String newFunction) {
		
		return 	((currentFunction != null) && (newFunction != null) && (currentFunction.equals(newFunction))) ||
				((currentFunction == null) && (newFunction == null));
	}
	
}