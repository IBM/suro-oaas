/**
 * 
 */
package com.ibm.au.optim.suro.couch;

import java.util.HashMap;
import java.util.Map;

import org.ektorp.CouchDbConnector;
import org.ektorp.CouchDbInstance;
import org.ektorp.http.HttpClient;
import org.ektorp.http.StdHttpClient;
import org.ektorp.impl.ObjectMapperFactory;
import org.ektorp.impl.StdCouchDbConnector;
import org.ektorp.impl.StdCouchDbInstance;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.ibm.au.optim.suro.model.store.impl.couch.AbstractCouchDbRepository;
import com.ibm.au.optim.suro.util.StringUtils;
import com.ibm.au.jaws.web.core.runtime.Environment;

/**
 * Class <b>CouchDbConnectionManager</b>. This class pulls the information from the {@link Environment}
 * and provides an instance of the {@link CouchDbConnector} object to client class. This component is
 * of use to different repository and services that require to interact directly with <i>CouchDb</i>.
 * 
 * @author Christian Vecchiola
 *
 */
public class CouchDbConnectionManager {
	

    /**
     * A {@link Logger} instance that can be used to record all the activities generated by
     * the instances of this class.
     */
    private static final Logger LOGGER = LoggerFactory.getLogger(CouchDbConnectionManager.class);
    
    /**
     * Class <b>CouchDbConnectorReference</b>. This class implements a simplified version of
     * a reference counter to the {@link CouchDbConnector} instance. It is used to dismiss the
     * connector instances when they are not used anymore by any of the client that originally
     * requested them.
     * 
     * @author Christian Vecchiola
     *
     */
    private static class CouchDbConnectorReference {
    	
    	/**
    	 * A {@link CouchDbConnector} instance that is object of multiple
    	 * request (referencing and dereferencing).
    	 */
    	private CouchDbConnector connector;
    	/**
    	 * A {@literal int} representing the number of active references
    	 * to the {@link CouchDbConnector} instance wrapped by this reference.
    	 */
    	private int references;
    	
    	
    	/**
    	 * Initialises an instance of {@link CouchDbConnectorReference} with the given
    	 * instance of {@link CouchDbConnector}. As a side effect the number of references
    	 * is set to 1.
    	 * 
    	 * @param connector	an instance of {@link CouchDbConnector}. It cannot be {@literal null}.
    	 * 
    	 * @throws IllegalArgumentException	if <i>connector</i> is {@literal null}.
    	 */
    	public CouchDbConnectorReference(CouchDbConnector connector) {
    		
    		if (connector == null) {
    			
    			throw new IllegalArgumentException("Parameter 'connector' cannot be null.");
    		}
    		
    		this.connector = connector;
    		this.references = 1;
    	}
    	
    	/**
    	 * Gets the underlying {@link CouchDbConnector} instance that is 
    	 * wrapped by this reference counter.
    	 * 
    	 * @return	a {@link CouchDbConnector} instance. 
    	 */
    	public CouchDbConnector getConnector() {
    		
    		return this.connector;
    	}
    	
    	/**
    	 * Increases the number of references to the underlying connector
    	 * instance by one unit. The method has only effect when the number
    	 * of references has not reached 0 yet.
    	 * 
    	 * @return	the updated value of the number of references.
    	 */
    	public int reference() {
    		
    		if (this.references > 0) {
    		
    			this.references += 1;
    		
    		}
    		
    		return this.references;
    	}
    	
    	/**
    	 * Decreases the number of references to the underlying connector
    	 * instance by one unit. The method has only effect when the number
    	 * of references has not reached 0 yet.
    	 * 
    	 * @return	the updated value of the number of references.
    	 */
    	public int deReference() {
    		
    		if (this.references > 0) {
    	
    			this.references -= 1; 
    		}
    		return this.references;
    	}
     }

    /**
     * A {@link Map} implementation that keeps track of the {@link CouchDbConnector} instances
     * that have been generated by the instances of {@link AbstractCouchDbRepository}. These
     * instances are shared across clients when the same credentials, url, and database match.
     */
    private static Map<String, CouchDbConnectorReference> connections = new HashMap<String, CouchDbConnectorReference>();
    

	
    /**
     * <p>
     * This method retrieves an instance of {@link CouchDbConnector} that is compatible with the
     * configuration parameters that are specified in the {@link CouchDbConnectionMetadata} argument
	 * that is passed to the method.
	 * </p>
     *
     * @param metadata 	an {@link CouchDbConnectionMetadata} instance that contains information
     * 					about the connection details to the selected <i>CouchDb</i> instance and
     * 					database.
     * 
     * @return 	an instance of {@link CouchDbConnector} that can be used to connect to the
     * 			<i>CouchDb</i> database specified by the credentials defined in <i>environment</i>.
     * 
     * @throws 	Exception 	if there is any error while initializing the connector.
     * @throws	IllegalArgumentException	if <i>metadata</i> is {@literal null}.
     */
    public static CouchDbConnector getInstance(CouchDbConnectionMetadata metadata) throws Exception {

    	if (metadata == null) {
    		
    		throw new IllegalArgumentException("Parameter 'metadata' cannot be null.");
    	}

        // the library needs only the host component, we need to remove
        // username and password from the url.
        //
        String url = metadata.getUrl();
        url = CouchDbConnectionManager.getHost(url);

        CouchDbConnectorReference ref = null;

        String hash = "" + metadata.hashCode();

        synchronized (CouchDbConnectionManager.connections) {

        	// we check whether we have it already or not.
        	//
            if (connections.containsKey(hash) == true) {
            	
            	// if we have it already we simply retrieve the
            	// reference and increase the number of client 
            	// that are using the connector.
            	//
                ref = connections.get(hash);
                ref.reference();

            } else {

            	// in this case we do not have a reference therefore
            	// we simply create a new connector and we set the
            	// number of client to 1 (default with the constructor
            	// of the reference).
            	//
                StdHttpClient.Builder clientBuilder = new StdHttpClient.Builder();
                clientBuilder = clientBuilder.url(url);

                String tmp = metadata.getUsername();
                if (StringUtils.isNullOrEmpty(tmp) == false) {
                    clientBuilder.username(tmp);
                }
                
                tmp = metadata.getPassword();
                if (StringUtils.isNullOrEmpty(tmp) == false) {
                    clientBuilder.password(tmp);
                }

                HttpClient dbHttpClient = clientBuilder.build();
                CouchDbInstance dbInstance = new StdCouchDbInstance(dbHttpClient);

                ObjectMapperFactory mapperFactory = new CouchDbMapperFactory();

                tmp = metadata.getDatabase();
                
                CouchDbConnector connector = new StdCouchDbConnector(tmp, dbInstance, mapperFactory);
                ref = new CouchDbConnectorReference(connector); // references = 1

                connections.put(hash, ref);


                LOGGER.info("CouchDb Connector: " + metadata.toString());
            }

        }

        return ref.getConnector();
    }
    /**
     * This method releases a reference to a {@link CouchDbConnector} instance that has been 
     * obtained through the given <i>metadata</i>. The method locates the {@link CouchDbConnector}
     * instance that corresponds to the given metadata and decreases its reference counter, if 
     * the number reaches 0, the connector is removed from the connections.
     * 
     * @param metadata	a {@link CouchDbConnectionMetadata} instance that was originally used
     * 					to retrieve an instance of {@link CouchDbConnector}.
     * 
     * @throws IllegalArgumentException	if <i>metadata</i> is {@literal null}.
     */
    public static void releaseInstance(CouchDbConnectionMetadata metadata) {
    	
    	if (metadata == null) {
    		
    		throw new IllegalArgumentException("Parameter 'metadata' cannot be null.");
    	}
    	
    	
    	String hash = "" + metadata.hashCode();
    	
    	synchronized (CouchDbConnectionManager.connections) {
    		
    		if (connections.containsKey(hash) == true) {
    			
    			CouchDbConnectorReference ref = connections.get(hash);
    			int references = ref.deReference();
    			if (references == 0) {
    				
    				connections.remove(hash);
    			}
    			ref = null;
    		}
    	}
    }


    /**
     * This method removes the user name and password component in the given url (if present)
     * and returns only the host component with the selected protocol.
     *
     * @param url 	a {@link String} representing the full <i>url</i>. It may contain the encoding of
     *            	the <i>username</i> and the <i>password</i> in the form: <i>protocol://username:password@host</i>.
     *            
     * @return 	the value of <i>procotol://host</i>, if <i>username</i> and <i>password</i> are
     * 			found, otherwise <i>url</i>
     */
    private static String getHost(String url) {

        int pivot = url.indexOf('@');
        if (pivot > -1) {

            String host = url.substring(pivot + 1);
            String protocol = url.substring(0, pivot);

            pivot = protocol.indexOf("://");
            protocol = protocol.substring(0, pivot + 3);

            host = protocol + host;

            return host;
        }

        return url;

    }

}
