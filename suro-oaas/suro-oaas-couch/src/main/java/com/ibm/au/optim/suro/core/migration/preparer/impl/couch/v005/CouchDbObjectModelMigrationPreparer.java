package com.ibm.au.optim.suro.core.migration.preparer.impl.couch.v005;


import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;

import org.ektorp.CouchDbConnector;
import org.ektorp.UpdateConflictException;
import org.ektorp.ViewQuery;
import org.ektorp.support.DesignDocument;
import org.ektorp.support.DesignDocument.View;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.ibm.au.jaws.web.core.runtime.Environment;
import com.ibm.au.optim.suro.couch.CouchDbConnectionManager;
import com.ibm.au.optim.suro.couch.CouchDbConnectionMetadata;
import com.ibm.au.optim.suro.couch.security.CouchDbSecurityEntity;
import com.ibm.au.optim.suro.model.admin.preference.SystemPreference;
import com.ibm.au.optim.suro.model.admin.preference.impl.couch.CouchDbSystemPreference;
import com.ibm.au.optim.suro.model.control.Core;
import com.ibm.au.optim.suro.model.entities.couch.CouchDbModel;
import com.ibm.au.optim.suro.model.entities.couch.CouchDbRun;
import com.ibm.au.optim.suro.model.entities.couch.CouchDbRunDetails;
import com.ibm.au.optim.suro.model.entities.couch.CouchDbTemplate;
import com.ibm.au.optim.suro.model.store.DatabasePreparer;


/**
 * Class <b>CouchDbObjectModelMigrationPreparer</b>. This class implements {@link DatabasePreparer} 
 * and performs a migration of the data model from the previous version to the new version. This model
 * actually transforms all the content of the documents in the database into the new version of the
 * model. The operations performed by this database preparer are performed at low level without relying
 * on the existence of the repositories but it operates directly via the underlying connector that
 * performs operations on raw types.
 * 
 * 
 * @author Christian Vecchiola
 *
 */
public class CouchDbObjectModelMigrationPreparer implements DatabasePreparer {

	/**
	 * A {@link Random} instance that is used to generate a salt number to be
	 * added to the temporary view names so that they do not clash with existing
	 * views.
	 */
	protected static Random rnd = new Random();
	
	/**
	 * A {@link Logger} implementation that is used to collect all the log messages that are
	 * generated by the instances of this class.
	 */
	public static final Logger LOGGER = LoggerFactory.getLogger(CouchDbObjectModelMigrationPreparer.class);
	
	/**
	 * A {@link String} constant defining the name of the parameter that controls whether 
	 * the preparer needs to check for transformation of documents that are prior to the
	 * the introduction of the <i>content</i> attribute.
	 */
	public static final String OBJECT_MODEL_PREPARER_CONTENT 	= 	"omp.content"; 
	
	/**
	 * A {@link String} constant defining the name of the parameter that controls the
	 * location of the trace file. When defined the preparer configures the transformation
	 * process to trace all the operation into a file.
	 */
	public static final String OBJECT_MODEL_PREPARER_TRACE		= 	"omp.trace";
	
	/**
	 * A {@link String} constant defining the name of the parameter that controls the
	 * execution mode of the preparer. By default this value is set to {@literal false}
	 * and this implies that the transformer will perform updates against the database.
	 * When set to {@literal true} the update operations will be skipped.
	 */
	public static final String OBJECT_MODEL_PREPARER_EMULATE	=	"omp.emulate";
	
	/**
	 * A {@link String} constant defining the name of the parameter that determines
	 * whether the transformation process should also proceed to update the database
	 * version number ({@literal true}) or not ({@literal false}). By default this
	 * value is set to {@literal true}.
	 */
	public static final String OBJECT_MODEL_PREPARER_UPGRADE	=	"omp.upgrade";
	
	/**
	 * A {@link String} constant containing the standard prefix of all the design documents that
	 * are stored in <i>CouchDb</i>.
	 */
	public static final String DESIGN_DOC_ID_PREFIX = "_design/";
	
	/**
	 * A {@link String} constant representing the name of the standard unique identifier
	 * of a <i>CouchDbDocument</i>.
	 */
	public static final String DOC_ID = "_id";

	/**
	 * A {@link String} constant containing the expected version number of the database. If
	 * a value smaller than this one is found the upgrade of the model will be retrieved.
	 */
	public static final String OBJECT_MODEL_VERSION 	= "0.0.5";
	/**
	 * A {@link String} constant containing the name of the property that contains the value
	 * of the object model version currently installed in the application.
	 */
	public static final String OBJECT_MODEL_PREFERENCE	= "object.model.version";
	
	/**
	 * A {@link String} constant containing the name of the attribute in the system preference
	 * document that contains the name of the preference.
	 */
	public static final String PREFERENCE_NAME 		= "name";
	
	/**
	 * A {@link String} constant containing the name of the attribute in the system preference
	 * document that contains the value of the preference.
	 */
	public static final String PREFERENCE_VALUE		= "value";	
	/**
	 * A {@link String} content containing the name of the attribute that discriminates the
	 * system preferences documents.
	 */
	public static final String PREFERENCE_DISCRIMINATOR = "cdbPreference";
	
	/**
	 * A {@link CouchDbConnector} instance that provides access to the database.
	 */
	protected CouchDbConnector connector;
	
	/**
	 * A {@link CouchDbConnectionMetadata} instance that can be used to retrieve an instance
	 * of {@link CouchDbConnector}, which is the primary point of access to a <i>CouchDb</i>
	 * database.
	 */
	protected CouchDbConnectionMetadata metadata;
	
	
	/**
	 * A {@link Map} implementation that contains the information about the <i>CouchDb</i>
	 * document storing the database version.
	 */
	protected Map<String,Object> dbVersion;
	
	/**
	 * A {@link Map} implementation that contains the information aobut the <i>CouchDb</i>
	 * document storing the version of the object model;
	 */
	protected Map<String,Object> omVersion;
	
	/**
	 * A {@literal boolean} flag that contains the information about whether we need to check
	 * for transformation prior to the introduction of the <i>content</i> attribute.
	 */
	protected boolean checkForContent = false;
	
	
	/**
	 * This method checks whether the current version of the database is prior to {@link 
	 * CouchDbObjectModelMigrationPreparer#OBJECT_MODEL_VERSION}.This value corresponds to an 
	 * updated data model for the entities stored in the database.
	 * 
	 * @param env	a {@link Environment} implementation that contains the configuration
	 * 				parameters and provides access to the shared components that have
	 * 				been loaded by the application.
	 * 

	 * @throws IllegalArgumentException	if <i>env</i> is {@literal null}.
	 * @throws Exception				if there is any other unexpected error.
	 * 
	 */
	@Override
	public boolean check(Environment env) throws Exception {

		if (env == null) {
			
			throw new IllegalArgumentException("Parameter 'env' cannot be null.");
		}

		
		this.checkForContent = env.getParameter(CouchDbObjectModelMigrationPreparer.OBJECT_MODEL_PREPARER_CONTENT, true);
		
		this.connector = this.getConnector(env);
		
		String currentDatabaseVersion = this.getDatabaseVersion();

		// we only need an update if there is a database version and we do have a 
		// different version number, more precisely the number should be inferior
		// because it does then mean that the data is based on an obsolete model.
		//
		boolean needsUpdate = (currentDatabaseVersion != null) &&
							  (currentDatabaseVersion.compareTo(CouchDbObjectModelMigrationPreparer.OBJECT_MODEL_VERSION) < 0);
		
		if (needsUpdate == false) {
			
			// in this case we might have migrated to 0.0.5 already, but we did
			// not applied the data migration before... So we check that the 
			// system preference for object model version is set.
			//
			if (CouchDbObjectModelMigrationPreparer.OBJECT_MODEL_VERSION.equals(currentDatabaseVersion) == true) {
				
				String value = this.getObjectModelVersion();
				needsUpdate = (value == null) || (value.compareTo(CouchDbObjectModelMigrationPreparer.OBJECT_MODEL_VERSION) < 0);
			}
			
		}
		
		if (needsUpdate == false) {
			
			// pre-release of the connection information because we
			// do not need the connection anymore.
			
			CouchDbConnectionManager.releaseInstance(this.metadata);
			this.connector = null;
		}
		
		return needsUpdate;
	}


	/**
	 * This method performs the planned changes to migrate instances of the
	 * following classes:
	 * <ul>
	 * <li><i>OptimizationModel</i></li>
	 * <li><i>Strategy</i></li>
	 * <li><i>Run</i></li>
	 * <li><i>OptimizationResult</i></li>
	 * </ul>
	 * to their corresponding classes:
	 * <ul>
	 * <li><i>Model</i></li>
	 * <li><i>Template</i></li>
	 * <li><i>Run</i></li>
	 * <li><i>RunDetails</li></li>
	 * </ul>
	 * As the two models contain the same information the transformation is
	 * lossless and feasible.
	 * 
	 * @param env	a {@link Environment} implementation that provides access to the
	 * 				configuration parameters and the shared object of the application.
	 * 
	 * @throws Exception if there is any error in the transformation process.
	 */
	@Override
	public void execute(Environment env) throws Exception {
		
		
		if (env == null) {
			
			throw new IllegalArgumentException("Parameter 'env' cannot be null.");
		}

		List<CouchDbDocumentTransformation> transformations = new ArrayList<CouchDbDocumentTransformation>();
		
		if (this.checkForContent == true) {
			
			CouchDbContentTransformation tContent = new CouchDbContentTransformation();
			tContent.setExcludeTriggers(CouchDbDocumentTransformation.DOCUMENT_CONTENT_ATTRIBUTE, CouchDbSecurityEntity.PROPERTY_SECURITY);
			transformations.add(tContent);
		}
		
		// Step 1. Model transformation.
		//
		CouchDbModelTransformation tModel = new CouchDbModelTransformation();
		transformations.add(tModel);
		
		// Step 2. Template transformation.
		//
		CouchDbTemplateTransformation tTemplate = new CouchDbTemplateTransformation();
		transformations.add(tTemplate);
		
		
		// Step 3 & 4. Run and RunDetails transformation.
		//
		CouchDbRunDetailsTransformation tDetails = new CouchDbRunDetailsTransformation();
		
		// we configure the run with the instance of run details so that
		// we can collect the information about the fields.
		//
		CouchDbRunTransformation tRun = new CouchDbRunTransformation();
		tRun.setRunDetailsTransformation(tDetails);
		transformations.add(tRun);
		transformations.add(tDetails);
		
		
		// Step 5. Fixup the security and remap the endpoints.
		//
		CouchDbRuleTransformation rRule = new CouchDbRuleTransformation();
		transformations.add(rRule);
		
		
		boolean emulate = env.getParameter(CouchDbObjectModelMigrationPreparer.OBJECT_MODEL_PREPARER_EMULATE, false);
		String traceFile = env.getParameter(CouchDbObjectModelMigrationPreparer.OBJECT_MODEL_PREPARER_TRACE, null);
		
		OutputStreamWriter writer = null;
		
		try {
		
			// we setup the trace support if the user has defined
			// a trace file.
			//
			if (traceFile != null) {
				
				try {
				
					writer = new OutputStreamWriter(new FileOutputStream(traceFile));
				
				} catch(IOException ioex) {
					
					LOGGER.error("Could not open trace file: " + traceFile, ioex);
				}
			}
			
			boolean everyThingOk = true;
			
			for(CouchDbDocumentTransformation t : transformations) {
				
				t.setConnector(connector);
				t.setEmulationMode(emulate);
				t.setTracer(writer);
				t.execute();
				
				everyThingOk = everyThingOk && t.isSuccessful();
			}
			
			
			// here we have to check whether the operation has been successful
			// or not.
			// 
			//
			//
			if (everyThingOk == false) {
				
				throw new CouchDbTransformationException("Data model migration did not complete successfully. Check the logs for details.");
			
			} 
			
			if (emulate == false) {
				
				// we should now check whether we need to upgrade the database
				// version.
				
				boolean upgrade = env.getParameter(CouchDbObjectModelMigrationPreparer.OBJECT_MODEL_PREPARER_UPGRADE, true);
				
				if (upgrade == true) {
					
					if (writer != null) {
					
						writer.write("Updgrading Database version to: " + CouchDbObjectModelMigrationPreparer.OBJECT_MODEL_VERSION);
					}
					
					this.setDatabaseVersion(CouchDbObjectModelMigrationPreparer.OBJECT_MODEL_VERSION);
				}
				
				// the version of the object model is always upgraded
				// because it needs to match.
			
				this.setObjectModelVersion(CouchDbObjectModelMigrationPreparer.OBJECT_MODEL_VERSION);
			
			}
		
		
		} finally {
			
			if (writer != null) {
				
				writer.close();
			}
			
			// in case we execute this code because of an Exception
			// being triggered we want to be sure that our connection
			// instance is released. 
			//
			this.connector = null;
			CouchDbConnectionManager.releaseInstance(this.metadata);
		}
	}
	



	/**
	 * <p>
	 * This method checks that there are now types that can be deserialised 
	 * into {@link Template}, {@link Model} and  @link Run} and {@link RunDetails}
	 * according to the new object model definition.
	 * </p>
	 * <p>
	 * If the transformation has been successful, and this is the reason why this
	 * method has been invoked, then this means that all the documents that are
	 * of relevance to the transformation process have been successfully trasformed
	 * and this means that they should be retrievable from the database.
	 * </p>
	 * 
	 * @param env	a {@link Environment} implementation that provides access to the
	 * 				configuration parameters and the shared objects of the application.
	 * 
	 * @return 	{@literal true} if the validation process succeed. In this case the 
	 *			converted documents are successfully deserialised into the new types
	 *			deifning the updated data model. If the returned value is {@literal 
	 *			false} this means that at least one class of documents has not been
	 *			transformed successfully.
	 *
	 * @throws IllegalArgumentException	if <i>env</i> is {@literal null}.
	 * @throws Exception				if there is any other unexpected error. 
	 */
	@Override
	public boolean validate(Environment env) throws Exception {
		
		
		if (env == null) {
			
			throw new IllegalArgumentException("Parameter 'env' cannot be null.");
		}
		
		boolean upgrade = env.getParameter(CouchDbObjectModelMigrationPreparer.OBJECT_MODEL_PREPARER_UPGRADE, true);

		
		
		try {

			this.connector = this.getConnector(env);
			
			// checking the database version it it was
			// update.
			//
			if (upgrade == true) {
				
				String version = this.getDatabaseVersion();
				if (version.equals(CouchDbObjectModelMigrationPreparer.OBJECT_MODEL_VERSION) == false) {
					
					LOGGER.error("Failed to upgrade the database version, current version is [actual: " + version + ", expected: " + CouchDbObjectModelMigrationPreparer.OBJECT_MODEL_VERSION + "].");

					return false;
				}
			}
				
			String	version = this.getObjectModelVersion();

			if (version.equals(CouchDbObjectModelMigrationPreparer.OBJECT_MODEL_VERSION) == false) {
				
				LOGGER.error("Failed to upgrade the database version, current version is [actual: " + version + ", expected: " + CouchDbObjectModelMigrationPreparer.OBJECT_MODEL_VERSION + "].");

				return false;
			}
			
					
			
		
			// Checking the model first.
			
			List<CouchDbModel> models = this.getEntities(CouchDbModel.class);
			if (models == null) {
				
				return false;
			}
			
			List<CouchDbTemplate> templates = this.getEntities(CouchDbTemplate.class);
			if ((templates == null) || (templates.isEmpty() == true)) {
					
				return false;	
			}
			
			List<CouchDbRun> runs = this.getEntities(CouchDbRun.class);
			if (runs == null) {
				
				return false;
			}
			
			List<CouchDbRunDetails> details = this.getEntities(CouchDbRunDetails.class);
			if (details == null) {
				
				return false;
			}
			
			return true;
		
		} finally {
			
			if (this.connector != null) {
				
				CouchDbConnectionManager.releaseInstance(this.metadata);
				this.connector = null;
			}
		}
	}
	
	/**
	 * Creates a {@link CouchDbConnector} instance that can be used to connect to the
	 * <i>CouchDb</i> database. The method retrieves that standard parameters defined
	 * in the {@link Environment} to access the database. It creates an instance of
	 * {@link CouchDbConnectionMetadata} and then will retrieve a connector instance
	 * from the {@link CouchDbConnectionManager}.
	 * 
	 * @param env	a {@link Environment} implementation that contains the configuration
	 * 				parameters and provides access to the shared components that have
	 * 				been loaded by the application.
	 * 
	 * @return	a {@link CouchDbConnector} instance that provides connectivity to the
	 * 			database.
	 * 
	 * @throws Exception	if there is any error while retrieving the expected parameters
	 * 						and / or getting an instance of the {@link CouchDbConnector}
	 * 						class.
	 */
	protected CouchDbConnector getConnector(Environment env) throws Exception {

		String database = env.getParameter(CouchDbConnectionMetadata.COUCHDB_DATABASE);
		String username = env.getParameter(CouchDbConnectionMetadata.COUCHDB_USERNAME);
		String password = env.getParameter(CouchDbConnectionMetadata.COUCHDB_PASSWORD);
		String url     = env.getParameter(CouchDbConnectionMetadata.COUCHDB_URL);
		
		this.metadata = new CouchDbConnectionMetadata(url, database, username, password);
		
		CouchDbConnector connector = CouchDbConnectionManager.getInstance(this.metadata);
		
		return connector;
	}
	
	/**
	 * <p>
	 * This method retrieves all the <i>CouchDb</i> documents that can be
	 * mapped to an instance of the type defined by the given <i>clazz</i>.
	 * If the upgrade of the data model has been successful, then all the
	 * documents are then serialised into the new definitions.
	 * </p>
	 * <p>
	 * The method creates a temporary view to select only those documents
	 * in the database that match the selected type. Adds the corresponding
	 * design document to the database and uses it to retrieve the collection
	 * of document of interest. Once the documents have been retrieved from
	 * database and cast back to the selected type, the view is removed.
	 * </p>
	 * 
	 * @param clazz	a {@link Class} instance that contains the information
	 * 				about the type to use for deserialise the <i>CouchDb</i>
	 * 				document into Java instances.
	 * 
	 * @return	a {@link List} implementation containing the collection of
	 * 			instances that have been retrieved from the database, or
	 * 			{@literal null} if it was not possible to deserialise some
	 * 			of the documents.
	 */
	protected <T> List<T> getEntities(Class<T> clazz) {
		
		List<T> entities = null;
		boolean viewCreated = false;
		
		String salt = "_" + CouchDbObjectModelMigrationPreparer.rnd.nextInt();
		String className = clazz.getSimpleName();
		String designDocId = CouchDbObjectModelMigrationPreparer.DESIGN_DOC_ID_PREFIX + className + salt;
		
		
		// we create a view on demand so that we can use
		// it query the collection of document that we
		// have just updated.
		//
		className = className.replace("CouchDb", "cdb");
		
		
		String map = "function(doc) { if (doc." + className  + ") { emit(null, doc._id); } }";
		DesignDocument designDoc = new DesignDocument();
		designDoc.setId(designDocId);
		View view = new View();
		view.setMap(map);
		designDoc.addView("all", view);
		
		
		try {
			
			this.connector.create(designDoc);
			viewCreated = true;
			
			ViewQuery vq = new ViewQuery();
			vq = vq.designDocId(designDocId)
				   .viewName("all")
				   .includeDocs(true);
			
			entities = this.connector.queryView(vq, clazz);
			
		} catch(Exception ex) {
			
			LOGGER.error("Data model upgrade failed for type: " + clazz.getSimpleName() + ".", ex);
		
		} finally {
			
			if (viewCreated == true) {
				
				this.connector.delete(designDoc);
			}
		}
		
		return entities;
		
	}
	
	/**
	 * This method retrieves the object model version. It does so by accessing
	 * the raw content of the system preference document that stores the information
	 * about the database version.
	 * 
	 * @return	a {@link String} representing the value of the system preference
	 * 			representing the object model version.
	 */
	protected String getObjectModelVersion() {
		
		String objectModelVersion = null;
		
		this.omVersion = this.getPreference(CouchDbObjectModelMigrationPreparer.OBJECT_MODEL_PREFERENCE);
		if (this.omVersion != null) {
			
			objectModelVersion = (String) this.unwrap(this.omVersion, CouchDbObjectModelMigrationPreparer.PREFERENCE_VALUE);
		}
		
		return objectModelVersion;
	}

	/**
	 * This method updates the object model version to the given value. The method
	 * checks whether it first found an object model version document in the system
	 * preference and if so, it simply updates the value otherwise it creates a new
	 * preference document with the given value for the version.
	 * 
	 * @param version	a {@link String} representing the version of the object model.
	 */
	protected void setObjectModelVersion(String version) {
		
		if (this.omVersion == null) {
			
			this.omVersion = new HashMap<String, Object>();
			
			Map<String,Object> content = new HashMap<String, Object>();
			content.put(CouchDbObjectModelMigrationPreparer.PREFERENCE_NAME, CouchDbObjectModelMigrationPreparer.OBJECT_MODEL_PREFERENCE);
			content.put(CouchDbObjectModelMigrationPreparer.PREFERENCE_VALUE, version);
			
			this.omVersion.put(CouchDbDocumentTransformation.DOCUMENT_CONTENT_ATTRIBUTE, content);
			this.omVersion.put(CouchDbObjectModelMigrationPreparer.PREFERENCE_DISCRIMINATOR, SystemPreference.class.getSimpleName());
			
			
			try {
				
				this.connector.create(this.omVersion);
				
			} catch(Exception ioex) {
				
				LOGGER.error("Could not insert the object model version, conflicting revision for preferences document.");
				
			}
		
		} else {
			
			this.setPreference(this.omVersion, version);
			
			try {
				
				this.connector.update(this.omVersion);
				
			} catch(Exception ex) {
				
				LOGGER.error("Could not update the object model version, conflicting revision for preferences document.");
			}
		}

		
	}
	

	/**
	 * This method retrieves the database version. It does so by accessing
	 * the raw content of the system preference document that stores the
	 * information about the database version.
	 * 
	 * @return	a {@link String} representing the value of the system
	 * 			preference representing the database version.
	 */
	protected String getDatabaseVersion() {
				
		String databaseVersion = null;
		
		this.dbVersion = this.getPreference(Core.PREFERENCE_DB_VERSION_NAME);
		if (this.dbVersion != null) {
			
			try {
			
				databaseVersion = (String) this.unwrap(this.dbVersion, CouchDbObjectModelMigrationPreparer.PREFERENCE_VALUE);
			
			} catch(Exception ex) {
				
				if ((this.checkForContent == true) && (this.dbVersion.containsKey(CouchDbDocumentTransformation.DOCUMENT_CONTENT_ATTRIBUTE) == false)) {
					
					databaseVersion = (String) this.dbVersion.get(CouchDbObjectModelMigrationPreparer.PREFERENCE_VALUE);
				
				} else {
					
					LOGGER.error("Error while retrieving information from the preference setting '" + Core.PREFERENCE_DB_VERSION_NAME + "'.",  ex);
				}
			}
		}
		
		return databaseVersion;
	}
	
	/**
	 * This method sets the database version to the specified version. A call to
	 * this method implies that previously the preparer has retrieved the document
	 * that contains the preference storing the database preference value. This
	 * previously fetched document will be updated and then persisted in the 
	 * database.
	 * 
	 * @param version	a {@link String} representing the version of the database
	 * 					to set. 
	 */
	@SuppressWarnings("unchecked")
	protected void setDatabaseVersion(String version) {
		
		try {
			

			String id = (String) this.dbVersion.get(CouchDbObjectModelMigrationPreparer.DOC_ID);

			this.dbVersion = (Map<String,Object>) this.connector.get(Map.class, id);
		
			this.setPreference(this.dbVersion, version);
			
			this.connector.update(this.dbVersion);
		
		
		} catch(UpdateConflictException ucex) {
			
			LOGGER.error("Could not update the database version, conflicting revision for preferences document.");
		}
		
	}

	/**
	 * This method retrieves the preference that has been specified as argument.
	 * The method uses the low-level view used by the system preference repository
	 * to select only those documents that are preferences that by unwrapping the
	 * content retrieves (if present) the one named <i>preferenceName</i>.
	 * 
	 * @param preferenceName	a {@link String} representing the name of the 
	 * 							preference being sought.
	 * 
	 * @return	the <i>CouchDb</i> document that contains the preference of interest
	 * 			or {@literal null} if not found.
	 */
	@SuppressWarnings("unchecked")
	protected Map<String,Object> getPreference(String preferenceName) {
		
		String prefDesignDocId = CouchDbObjectModelMigrationPreparer.DESIGN_DOC_ID_PREFIX + CouchDbSystemPreference.class.getSimpleName();
		
		ViewQuery query = new ViewQuery();
		query = query.designDocId(prefDesignDocId)
					 .viewName("all")
					 .includeDocs(true);
		
		
		Map<String, Object> preference = null;
		
		@SuppressWarnings("rawtypes")
		List<Map> preferences = this.connector.queryView(query, Map.class);
		for(Map<String,Object> p : preferences) {
			
			
			String name = null;

			
			try {
				
				name = (String) this.unwrap(p, CouchDbObjectModelMigrationPreparer.PREFERENCE_NAME);

			
			} catch(Exception ex) {
				
				
				if (this.checkForContent == true) {
					
					if (p.containsKey(CouchDbDocumentTransformation.DOCUMENT_CONTENT_ATTRIBUTE) == false) {
					
						// ok we might still be in the case of the old structure for the
						// documents therefore, we will try...
						name = (String) p.get(CouchDbObjectModelMigrationPreparer.PREFERENCE_NAME);
						
					}
				} else {
					
					LOGGER.error("Invalid content retrieved for preference document.", ex);
				}
			}
			
			if ((name != null) && (preferenceName.equals(name) == true)) {
					
					preference = p;
					break;
			}
			

		}
		
		return preference;
		
	}
	
	/**
	 * This method sets the value of the preference for the given <i>CouchDb</i>
	 * document. The method unwraps the document and sets the value attribute
	 * of the document content to <i>value</i>
	 * 
	 * @param document	a {@link Map} implementation that represents the preference
	 * 					document.
	 * 					
	 * @param value		a {@link Object} reference representing the value of the
	 * 					preference to set.
	 */
	protected void setPreference(Map<String,Object> document, Object value) {
		
		
		@SuppressWarnings("unchecked")
		Map<String,Object> content = (Map<String,Object>) document.get(CouchDbDocumentTransformation.DOCUMENT_CONTENT_ATTRIBUTE);
		content.put("value", value);
	}
	
	/**
	 * This method is used to retrieve a specific attribute of the entity that is 
	 * wrapped within a <i>CouchDb</i> document. This method extracts the value of  
	 * the {@link CouchDbDocumentTransformation#DOCUMENT_CONTENT_ATTRIBUTE} and then
	 * it extracts the value of the attribute.
	 * 
	 * @param document	a {@link Map} implementation that represents the <i>CouchDb</i>
	 * 					document to unwrap.
	 * @param attribute	a {@link String} representing the name of the attribute whose
	 * 					value will be extracted.
	 * 
	 * @return	a {@link Object} reference that represents the value of <i>attribute</i>.
	 * 			If <i>attribute</i> is not found, the value returned is {@literal null}.
	 */
	protected Object unwrap(Map<String, Object> document, String attribute) {
		
		@SuppressWarnings("unchecked")
		Map<String,Object> content = (Map<String,Object>) document.get(CouchDbDocumentTransformation.DOCUMENT_CONTENT_ATTRIBUTE);
		
		return content.get(attribute);
		
	}
	


}
