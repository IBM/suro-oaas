/**
 * 
 */
package com.ibm.au.optim.suro.core.migration.preparer.impl.couch.v005;

import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import org.ektorp.CouchDbConnector;
import org.ektorp.DocumentNotFoundException;
import org.ektorp.Page;
import org.ektorp.PageRequest;
import org.ektorp.UpdateConflictException;
import org.ektorp.ViewQuery;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.ibm.au.jaws.data.utils.map.MapUtils;


/**
 * Class <b>DocumentTransformation</b>. This class encapsulates the
 * information about the documents that have been transformed for a
 * specific type of document. This class is helpful to collect the
 * details about which documents have failed the transformation or
 * the update to the database.
 * 
 * @author Christian Vecchiola
 *
 */
public abstract class CouchDbDocumentTransformation {
	
	/**
	 * A {@link Logger} implementation that is used to collect all the log messages
	 * generated by the instances of this class.
	 */
	private static final Logger LOGGER = LoggerFactory.getLogger(CouchDbDocumentTransformation.class);
	
	/**
	 * A {@link String} constant containing the name of the attributes that stores
	 * the type specific attributes of a <i>CouchDb</i> document. In the current
	 * implementation <i>CouchDb</i> documents are wrapper around the type specific
	 * attributes, and the top level attributes of the document are only the id, the
	 * revision, and the attachments.
	 */
	public static final String DOCUMENT_CONTENT_ATTRIBUTE = "content";
	
	/**
	 * A {@literal int} constant that defines the default page size for retrieving
	 * the documents from the database.
	 */
	public static final int DEFAULT_PAGE_SIZE = 50;

	
	/**
	 * A {@link String} representing the name of the design document that defines the 
	 * group of document this instance of {@link  DocumentTransformation} relates to, 
	 * without the standard prefix. The convention of the <i>Ektorp</i> library is to 
	 * use the simple class name of the bean that will be used for type mapping when 
	 * deserialising the document into a Java object.
	 */
	protected String name;
	
	/**
	 * A {@link List} implementation that contains the list of
	 * documents that have not been converted. 
	 */
	protected List<Map<String,Object>> failedToConvert;
	
	/**
	 * A {@link List} implementation that contains the list of
	 * documents that the application has not been able to 
	 * update, despite the transformation was successful. The
	 * content of this list is represented by converted documents.
	 */
	protected List<Map<String,Object>> failedToUpdate;
	
	/**
	 * A {@literal int} value containing the total number of documents that
	 * have been retrieved from via the view selecting the specified subset
	 * of documents, identified by {@link CouchDbDocumentTransformation#getName()}.
	 */
	protected int totalDocuments = 0;
	
	/**
	 * A {@link CouchDbConnector} instance used to provide connectivity
	 * to the <i>CouchDbDatabase</i> that contains the documents to be
	 * transformed.
	 */
	protected CouchDbConnector connector;
	
	/**
	 * A {@literal boolean} value indicating whether the transformation should
	 * run in emulation mode. By default this flag is set to {@literal false}.
	 * When set to {@literal true} the update to the database is skipped and
	 * only the conversion is performed.
	 */
	protected boolean emulationMode = false;
	
	/**
	 * A {@literal boolean} value indicating whether at the end of the transformation
	 * the original view that was used to retrieve all the document of this specific
	 * type needs to be deleted. This is helpful when the class names change and we
	 * do not want to keep in the database spurius views that are associated to types
	 * that do not exist anymore.
	 */
	protected boolean deleteView = false;
	
	/**
	 * A {@literal int} value that indicates the size of the page used to retrieve
	 * the documents from the database. For very large databases we cannot pull
	 * down all the document at once.
	 */
	protected int pageSize = CouchDbDocumentTransformation.DEFAULT_PAGE_SIZE;
	
	/**
	 * An {@link PrintWriter} implementation that can be used to trace the
	 * transformation of each and every single document. The trace stream is
	 * inactive by default.
	 */
	protected PrintWriter tracer;
	
	/**
	 * A {@link ObjectMapper} instance that is used to convert {@link Map}
	 * implementation into JSON documents that can be serialised to a
	 * {@link String} for the purpose of tracing.
	 */
	protected ObjectMapper mapper;
	
	/**
	 * Initialises a instance of {@link CouchDbDocumentTransformation} for the 
	 * specific type of document, whose class name is <i>name</i>.
	 * 
	 * @param name	a {@link String} representing the simple class name of the
	 * 				documents that are going to be converted. The convention of
	 * 				the <i>Ektorp</i> library is to use the simple class name of 
	 * 				the bean that will be used for type mapping when deserialising 
	 * 				the document into a Java object. It cannot be {@literal null}.
	 * 
	 * @throws IllegalArgumentException	if <i>name</i> is either {@literal 
	 * 									null} or an empty string.
	 * 		
	 */
	public CouchDbDocumentTransformation(String name) {
		
		if ((name == null) || (name.isEmpty() == true)) {
			
			throw new IllegalArgumentException("Parameter 'name' cannot be null or an empty string.");
		}
		
		this.name = name;
		this.failedToConvert = new ArrayList<Map<String,Object>>();
		this.failedToUpdate = new ArrayList<Map<String,Object>>();
	}
	
	/**
	 * Gets the simple class name that defines the class of document
	 * being transformed. By convention the <i>Ektorp</i> library uses
	 * the simple class name of the Java bean used to represent the
	 * document in the Java runtime to compose the unique identifier
	 * of the design document.
	 * 
	 * @return	a {@link String} representing the simple name of the
	 * 			class defining the types of document being transformed.
	 * 			It cannot be {@literal null}.
	 */
	public String getName() {
		
		return this.name;
	}
	
	/**
	 * Sets the {@link CouchDbConnector} instance used to provide 
	 * connectivity towards the <i>CouchDb</i> instance that contains
	 * the documents to be transformed.
	 * 
	 * @param connector	a {@link CouchDbConnector} instance.
	 */
	public void setConnector(CouchDbConnector connector) {
		
		this.connector = connector;
	}
	
	/**
	 * This method returns the value of the emulation mode flag. When
	 * this flag is set to {@literal true} the process is performed 
	 * without the update to the database, so that the original data
	 * remains intact. By default this value is set to {@literal false}.
	 * 
	 * @return	{@literal true} if the emulation mode is active, 
	 * 			{@literal false} otherwise.
	 */
	public boolean isEmulationMode() {
		
		return this.emulationMode;
	}
	
	/**
	 * Sets the emulation mode flag. This flag controls whether the updates
	 * to the database are performed or not, once the conversion is completed.
	 * By default the update is executed. 
	 * 
	 * @param emulationMode	a {@literal boolean} value indicating whether the
	 * 						emulation mode is active {@literal true} or not
	 * 						{@literal false}.
	 */
	public void setEmulationMode(boolean emulationMode) {
		
		this.emulationMode = emulationMode;
	}
	
	/**
	 * <p>
	 * This method gets the flag that controls the deletion of the design
	 * document that is associated to the collection of documents that are
	 * managed by this transformation.
	 * </p>
	 * <p>
	 * Deleting a view is required when from one version to another of the
	 * data model the class names change. Because of the default behaviour
	 * of the <i>Ektorp</i> library, we would have a view that is no longer
	 * used by any code, since it will respond to a name that does not map
	 * the class currently used.
	 * </p>
	 * 
	 * @return	{@literal true} if the design document will be deleted, or
	 * 			{@literal false} otherwise. The default is {@literal false}.
	 */
	public boolean getDeleteView() {
		
		return this.deleteView;
	}
	
	/**
	 * <p>
	 * This method sets the flag that controls the deletion of the design
	 * document that is associated to the collection of documents that are
	 * managed by this transformation.
	 * </p>
	 * <p>
	 * Deleting a view is required when from one version to another of the
	 * data model the class names change. Because of the default behaviour
	 * of the <i>Ektorp</i> library, we would have a view that is no longer
	 * used by any code, since it will respond to a name that does not map
	 * the class currently used.
	 * </p>
	 * 
	 * @param deleteView	{@literal true} to configure the deletion of the
	 * 						design document, {@literal false} otherwise. 
	 */
	public void setDeleteView(boolean deleteView) {
		
		this.deleteView = deleteView;
	}
	


	/**
	 * This method sets the {@link OutputStreamWriter} instance that can be used
	 * to trace all the document transformation that are applied to the documents
	 * retrieved from the database. A non {@literal null} instance activates the
	 * tracing mode. By default this attribute is set to {@literal null}.
	 * 
	 * @param tracer	a {@link OutputStreamWriter} instance that can be used to
	 * 					trace the document transformations. It can be {@literal null},
	 */
	public void setTracer(OutputStreamWriter tracer) {
		
		this.tracer = (tracer == null ? null : new PrintWriter(tracer));
	}

	/**
	 * Sets the configured page size. This value controls the number of documents
	 * that are retrieved at once when issuing queries to the database. For very
	 * large databases we cannot retrieve all the documents of interest at once.
	 * 
	 * @return	pageSize	an {@literal int} representing the configured page size. 
	 * 
	 */
	public void setPageSize(int pageSize) {
		
		this.pageSize = pageSize;
	}
	
	/**
	 * Gets the configured page size. This value controls the number of documents
	 * that are retrieved at once when issuing queries to the database. For very
	 * large databases we cannot retrieve all the documents of interest at once.
	 * 
	 * @return	an {@literal int} representing the configured page size. The default
	 * 			value is {@link CouchDbDocumentTransformation#DEFAULT_PAGE_SIZE}.
	 */
	public int getPageSize() {
		
		return this.pageSize;
	}
	
	/**
	 * Executes the transformation of the documents. This method generates
	 * a {@link ViewQuery} instance to select all those instances that are
	 * mapped to a specific bean in Java. It then queries the database for
	 * all those documents that match the generated view and for each of
	 * them executes the {@link CouchDbDocumentTransformation#transform(Map)}
	 * which defines the specifics of the transformation.
	 * 
	 * @throws CouchDbTransformationException	if there is any error that is
	 * 											not recoverable during the
	 * 											transformation process.
	 */
	public void execute() throws CouchDbTransformationException {
		
		// Step 0. We clean up the fields in case there was a previous
		//		   excution.
		//
		this.totalDocuments = 0;
		this.failedToConvert.clear();
		this.failedToUpdate.clear();
		
		this.beginTracing();
		
		LOGGER.info("Document type: " + this.getName());
		
		if (this.connector != null) {
			
			// Step 2. Process all the documents in the database.
			//
			this.process();
			
			
			// Step 3. We check whether we need to delete the view.
			//
			if ((this.isEmulationMode() == false) && (this.deleteView == true)) {
				
				this.deleteDesignDocument();
			}
			
			LOGGER.info("Total documents processed:         " + this.getTotalDocuments());
			LOGGER.info("Documents that failed to convert:  " + this.getFailedToConvert().size());
			LOGGER.info("Documents that failed to update:   " + this.getFailedToUpdate().size());
			
		} else {
			
			LOGGER.error("Could not perform the transformation process, no connection the database.");
		}
		
		this.endTracing();
		
		
	}

	/**
	 * This method loops through all the documents in the database and transform
	 * each of them to comply with the new version of the data model. According to
	 * whether the emulation mode is active or not it will update the database.
	 * 
	 * @throws CouchDbDocumentTransformationException	if there is any error while
	 * 													processing the documents.
	 */
	protected void process() throws CouchDbDocumentTransformationException {
		

		boolean emulate = this.isEmulationMode();
		
		PageRequest request = PageRequest.firstPage(this.getPageSize());
		
		@SuppressWarnings("rawtypes")
		Page<Map> page = this.getDocuments(request);

		int processedDocuments = 0;
		boolean hasNextPage = true;

		if (page != null) {
			this.totalDocuments = page.getTotalSize();


			do {

				for(Map<?,?> document : page.getRows()) {


					@SuppressWarnings("unchecked")
					Map<String,Object> source = (Map<String,Object>) document;

					String id = (String) source.get(CouchDbObjectModelMigrationPreparer.DOC_ID);

					LOGGER.info("Converting document: " + id);


					// Step 2. Transform and update the documents.
					//
					try {

						Map<String,Object> target = this.transform(id, source);

						this.trace(id, source, target);

						if (emulate == false) {

							LOGGER.info("Updating document: " + id);

							this.update(id, target);
						}

					} catch(CouchDbDocumentTransformationException ex) {

						this.addFailedToConvert(id, source);

					}

				}

				// we just dump some information to be sure that we keep an eye on what is going on.
				//
				processedDocuments += page.getRows().size();
				int percentage = Math.round(((float) processedDocuments / (float) this.totalDocuments) * 100);
				LOGGER.debug("Processed [page: " + request.getPageNo() + ", items: " + processedDocuments + "/" + this.totalDocuments + ", progress: " + percentage + "%].");

				hasNextPage = page.isHasNext();

				if (hasNextPage) {
					request = page.getNextPageRequest();
					page = this.getDocuments(request);

					// would usually happen earlier, when the view is requested for the first time
					if (page == null) {
						// handle error when requesting the next page
						hasNextPage = false;
					}

				}

			} while(hasNextPage == true);

		}

	}
	
	/**
	 * This method retrieves the design document associated to the documents
	 * that are managed by this transformation and deletes it from the database.
	 * If there is any error or exception, this is logged.
	 */
	protected void deleteDesignDocument() {
		
		String designDoc = CouchDbObjectModelMigrationPreparer.DESIGN_DOC_ID_PREFIX + this.getName();
		
		LOGGER.info("Deleting design document. [" + designDoc + "]");

		Map<?,?> doc = null;
		try {
			doc = this.connector.get(Map.class, designDoc);
		} catch (DocumentNotFoundException noView) {
			LOGGER.warn("Requested view doesn't exist", noView);
		}

		
		if (doc != null) {
		
			try {
				
				this.connector.delete(doc);
			
			} catch(UpdateConflictException ucex) {
				
				LOGGER.error("Could not delete the design document  [id: " + designDoc + "].");
			}
		
		} else {
			
			LOGGER.warn("Design document not found [id: " + designDoc +"]");
		}
		
	}

	/**
	 * This is a callback for concrete classes for specialising the update process
	 * of the converted documents. The default implementation is to try to perform
	 * the update and then capture the {@link UpdateConflictException} and to add
	 * the document that originated the exception into the list of documents whose
	 * update failed.
	 * 
	 * @param target	a {@link Map} implementation contaning the converted fields
	 * 					of the document that will be used for the update.
	 * 
	 */
	protected void update(String id, Map<String, Object> target) {
		
		try {
			
			this.connector.update(target);
			
		} catch(UpdateConflictException uex) {
			
			this.addFailedToUpdate(id, target);
		}
		
	}

	/**
	 * Gets the total number of documents that are identified by the 
	 * specified simple class name (see {@link #getName()}.
	 * 
	 * @return	a {@literal int} containing the total number of matching
	 * 			documents retrieved.
	 */
	public int getTotalDocuments() {
		
		return this.totalDocuments;
	}
	
	
	/**
	 * Gets the documents that, despite being converted, could not be
	 * updated, for conflict reasons. It all the converted documents
	 * are updated, this list is empty, but not {@literal null}.
	 * 
	 * @return	a {@link List} implementation containing the {@link Map}
	 * 			instances representing the converted document that have
	 * 			not been updated. 
	 */
	public List<Map<String,Object>> getFailedToUpdate() {
		
		return this.failedToUpdate;
	}

	/**
	 * Gets the documents that could not be converted. For instance for
	 * structure incompatibility. It all the original documents can be
	 * converted, this list is empty, but not {@literal null}.
	 * 
	 * @return	a {@link List} implementation containing the {@link Map}
	 * 			instances representing the original documents that have
	 * 			not been converted. 
	 */
	public List<Map<String,Object>> getFailedToConvert() {
		
		return this.failedToConvert;
	}
	
	/**
	 * Checks whether the conversion has been successful. A successful 
	 * conversion implies that all the documents have been converted 
	 * and updated in the database.
	 * 
	 * @return	{@literal true} if both the list <i>failedToConvert</i>
	 * 			and the list <i>failedToUpdate</i> are empty.
	 */
	public boolean isSuccessful() {
		
		return (this.failedToConvert.isEmpty() == true) && 
			   (this.failedToUpdate.isEmpty() == true);
	}
	
	/**
	 * <p>
	 * This is a callback for the concrete classes that can be used to specialise
	 * the transformation of the document. This method will return the transformed
	 * instance, which is supposed to be a different instance of the one passed as
	 * argument, if the transformation is successful. If there is an error during
	 * the process of it was not possible to complete the transformation, the 
	 * method should throw the {@link CouchDbDocumentTransformationException}.
	 * </p>
	 * <p>
	 * The current implementation simply maps the qualifier that is used by the design
	 * document to retrieve all documents of a specific type to the new name and the
	 * new value.
	 * </p>
	 * 
	 * @param id		a {@link String} representing the unique identifier of the
	 * 					document.
	 * 
	 * @param source	a {@link Map} representing the original document that needs
	 * 					to be transformed. It is supposed to not to be {@literal null}.
	 * 
	 * @return	a {@link Map} representing the transformed document.
	 * 
	 * @throws CouchDbDocumentTransformationException	if any error occurs during 
	 * 													the transformation.
	 */
	protected Map<String, Object> transform(String id, Map<String,Object> source) throws CouchDbDocumentTransformationException {
		
		Map<String,Object> target = MapUtils.clone(source, true);
		
		// we remap the type discriminator if needed, otherwise we simply change
		// the name.
		//
		String oldProperty = this.getOldTypeDiscriminator();
		String newProperty = this.getNewTypeDiscriminator();
		
		if (oldProperty.equals(newProperty) == false) {
			
			target.remove(oldProperty);
		}
		
		String newValue = this.getTypeDiscriminatorValue();
		
		target.put(newProperty, newValue);
		
		@SuppressWarnings("unchecked")
		Map<String,Object> content = (Map<String,Object>) target.get(CouchDbDocumentTransformation.DOCUMENT_CONTENT_ATTRIBUTE);
		
		// we transform the content, this is where most of the work occurs.
		//
		content = this.transformContent(id, content);
		
		// we replace the reference with the new one, just in case a new instance has
		// been used.
		//
		target.put(CouchDbDocumentTransformation.DOCUMENT_CONTENT_ATTRIBUTE, content);
		
		return target;
	}
	
	/**
	 * Gets the name of the property that is used by the <i>Ektorp</i> library as a
	 * type discriminator to return all those documents that match the desired Java
	 * type. The specific value returned by this method is the one used by in the
	 * old implementation of the data model, and that will be replaced by the new one
	 * as specified by {@link CouchDbDocumentTransformation#getNewTypeDiscriminator()}.
	 * 
	 * @return	a {@link String} containing the old name of the type discriminator 
	 * 			property.
	 */
	protected abstract String getOldTypeDiscriminator();
	
	/**
	 * Gets the name of the property that is used by the <i>Ektorp</i> library as a
	 * type discriminator to return all those documents matching the desired Java
	 * type. This value is refers to the new qualifier (if changed) that is used in
	 * the updated data model and if different it will replace the previous one that
	 * is specified by {@link CouchDbDocumentTransformation#getOldTypeDiscriminator()}.
	 * 
	 * 
	 * @return	a {@link String} containing the new name of the type discriminator
	 * 			property.
	 */
	protected abstract String getNewTypeDiscriminator();
	
	/**
	 * Gets the updated value of the type discriminator property. 
	 * 
	 * @return	a {@link String} containing the value of the property.
	 */
	protected abstract String getTypeDiscriminatorValue();
	
	/**
	 * <p>
	 * This is a callback that is used to specialise the transformation of the <i>content</i>
	 * section of the document. The current implementation stores the type specific attributes
	 * into a <i>content</i> attribute, while the <i>CouchDb</i> document entity acts as a
	 * wrapper that managed the unique identifier, the revision, and the attachments.
	 * </p>
	 * <p>
	 * The document is expected to perform a transformation in place and not to clone the
	 * given content into another instance. It can return (if convenient) the very same
	 * instance passed as argument.
	 * </p>
	 * 
	 * @param id		a {@link String} representing the unique identifier of the document.
	 * 
	 * @param content	a {@link Map} implementation containing the type specific portion of
	 * 					the <i>CouchDb</i> document.
	 * 
	 * @return	a {@link Map} implementation representing the transformed set of attributes.
	 * 
	 * @throws CouchDbDocumentTransformationException	if there is any error in the conversion.
	 */
	protected abstract Map<String,Object> transformContent(String id, Map<String,Object> content) throws CouchDbDocumentTransformationException;

	/**
	 * <p>
	 * This method creates a view query that can retrieve all (and only) those
	 * documents that represent the same type in the Java runtime. The method
	 * uses the <i>documentType</i> parameter and composes it with the standard
	 * prefix for design document, to generate the unique identifier of the 
	 * design document to use for composing the query.
	 * </p>
	 * <p>
	 * By convention the <i>Ektorp</i> library generates a design document for
	 * each of the different Java types whose instances are stored in the database.
	 * By querying the document through a query view that has an associated design
	 * document id it is possible to retrieve all the documents that can be safely
	 * mapped to a Java type. This capability is provided as a built-in feature in
	 * the library, and the convention used to associate the design doc id to a
	 * specific class name is to use the simple class name of the Java type as the
	 * suffix for the design document identifier.
	 * </p>
	 * 
	 * @param documentType	a {@link String} representing the simple class name
	 * 						of the Java type that identifies the type of documents
	 * 						to be queried through the generated view. It cannot be
	 * 						{@literal null} or an empty string.
	 * 
	 * @return	a {@link ViewQuery} configure to retrieve a collection of documents
	 * 			via design document identifier.
	 * 
	 * @throws IllegalArgumentException		if <i>documentType</i> is {@literal null}
	 * 										or an empty string.
	 */
	protected ViewQuery getViewQueryFor(String documentType) {
		
		if ((documentType == null) || (documentType.isEmpty() == true)) {
			
			throw new IllegalArgumentException("Parameter 'documentType' cannot be null or an empty string.");
		}
		
		// we construct the view that is used to retrieve all the documents
		// of a certain type. The type is 
		//
		ViewQuery view = new ViewQuery();
		view = view.designDocId(CouchDbObjectModelMigrationPreparer.DESIGN_DOC_ID_PREFIX + documentType)
				   .viewName("all")
				   .includeDocs(true);
		
		
		return view;
	}

	/**
	 * This method is callback for concrete classes that can be used to specialise
	 * the way in which the collection of documents are retrieved from the <i>CouchDb</i>
	 * instance. The default implementation generates a {@link ViewQuery} instance that
	 * selects document based on the associated design document id.
	 * 
	 * @param request	a {@link PageRequest} instance containing the request for a specific
	 * 					page of documents.
	 * 
	 * @return	a {@link Page} containing the collection of documents that have been retrieved
	 * 			with the given page <i>request</i>.
	 */
	@SuppressWarnings("rawtypes")
	protected Page<Map> getDocuments(PageRequest request) {

		String name = this.getName();
		ViewQuery query = this.getViewQueryFor(name);
		
		// [CV] TODO
		//
		try {
			Page<Map> page = this.connector.queryForPage(query, request, Map.class);
			return page;
		} catch (DocumentNotFoundException noSuchView) {
			LOGGER.warn("During migration a requested view didn't exist", noSuchView);
		}

		return null;

	}
	
	/**
	 * This is a callback for concrete classes for specialising the behaviour that 
	 * is executed when a document that has been successfully converted cannot be
	 * updated. The default implementation adds this document to the list of documents
	 * that could not be updated.
	 * 
	 * @param id		a {@link String} representing the unique identifier of the
	 * 					document.
	 * 
	 * @param converted	a {@link Map} implementation that contains the fields of the
	 * 					document that was converted.
	 */
	protected void addFailedToUpdate(String id, Map<String,Object> converted) {
		
		LOGGER.error("Could not update document: [id:  " + id + ", type: " + this.getName() + "].");
		
		this.failedToUpdate.add(converted);
	}
	

	/**
	 * This is a callback for concrete classes for specialising the behaviour that 
	 * is executed when a document cannot be converted. The default implementation 
	 * adds this document to the list of documents that could not be converted.
	 * 
	 * @param id		a {@link String} representing the unique identifier of the
	 * 					document.
	 * 
	 * @param source	a {@link Map} implementation that contains the fields of the
	 * 					original document that was not converted.
	 */
	protected void addFailedToConvert(String id, Map<String,Object> source) {
		
		this.trace(id, source, null);
		
		LOGGER.error("Could not convert document: [id:  " + id + ", type: " + this.getName() + "].");
		
		this.failedToUpdate.add(source);
	}
	
	/**
	 * This method initialises the tracing session. It simply provides some
	 * textual marker and header information to easily identify the section
	 * that relates to a transformation of a class of documents.
	 */
	protected void beginTracing() {
		
		if (this.tracer != null) {

			this.tracer.println();
			this.tracer.println();
			this.tracer.println("[===== BEGIN TRACING (" + this.getName() + ") =====]");
			this.tracer.println();
			this.tracer.println();
			
			if (this.mapper == null) {
				
				this.mapper = new ObjectMapper();
			}
		}
	}
	
	/**
	 * This method is used to trace the specific transformation of a given
	 * document instance into its new version.
	 * 
	 * @param id		a {@link String} representing the unique identifier of the
	 * 					document.
	 * 
	 * @param source	a {@link Map} implementation that contains the fields
	 * 					of the original document. It should not be {@literal null}.
	 * 
	 * @param target	a {@link Map} implementation that contains the fields
	 * 					of the transformed document. It can be {@literal null}
	 * 					if the transformation has failed.
	 */
	protected void trace(String id, Map<String,Object> source, Map<String,Object> target) {
		
		if (this.tracer != null) {
			
			this.tracer.println("[ID: " + id +"]");
			
			String dump = null;
			
			if (source != null) {
				
				try {
					
					this.tracer.println();
					this.tracer.println("[Original]");
					dump = this.mapper.writeValueAsString(source);
					this.tracer.println(dump);
					
				
				} catch(IOException ioex) {
					
					this.tracer.println("<<ERROR>>");
					LOGGER.error("Error while serialising the source document to JSON. [id: " + id + "].", ioex);
				}
			
			}
			
			if (target != null) {
			
				try {
					
					this.tracer.println();
					this.tracer.println("[Transformed]");
					dump = this.mapper.writeValueAsString(target);
					this.tracer.println(dump);
					
				
				} catch(IOException ioex) {
					
					this.tracer.println("<<ERROR>>");
					LOGGER.error("Error while serialising the target document to JSON. [id: " + id + "].", ioex);
				}
			
			}
			this.tracer.println();
			this.tracer.println();
			
		}
	}
	/**
	 * This method remaps the keys that are set in <i>content</i> with the values of the corresponding
	 * properties that are defined in <i>properties</i>. The value of <i>deleteMissing</i> defines the
	 * action that needs to be taken when an attribute is not defined the <i>properties</i>.
	 * 
	 * @param mappings		a {@link Properties} object that contains the mapping of the attribute names 
	 * 						used as keys in <i>content</i> to the corresponding values of the new keys.
	 * @param content		a {@link Map} implementation containing the key-value pairs that need to be
	 * 						remapped.
	 * @param deleteMissing	a {@literal boolean} flag indicating whether a missing key needs to be deleted
	 * 						or not.
	 */
	protected void remap(Properties mappings, Map<String,Object> content, boolean deleteMissing) {
		
		// we change some of the values and map them
		// to the corresponding names we want to use
		//
		
		int size = content.size();
		String[] keys = new String[size];
		content.keySet().toArray(keys);
		
		for(String attributeName : keys) {
			
			// if we remove it first, we are at the same time
			// cleaning all those attributes that we do not
			// want to include anymore.
			//
			Object value = (deleteMissing == true ? content.remove(attributeName) : content.get(attributeName));
			String newName = mappings.getProperty(attributeName);
			
			
			if (newName != null) {
				
				// ok we have a match, therefore
				// we add it in.
				//
				content.put(newName, value);
			}
		}
		
	}
	
	/**
	 * This method finalises the tracing sessions. It simply provides some 
	 * textual marker to easily identify the section that relates to a set
	 * of documents of the same type.
	 */
	protected void endTracing() {
		
		if (this.tracer != null) {

			this.tracer.println();
			this.tracer.println();
			this.tracer.println("[===== END TRACING (" + this.getName() + ") =====]");
			this.tracer.println();
			this.tracer.println();
		}
		
	}
}