/**
 * Copyright (C) 2015 IBM Corporation
 * All Rights Reserved
 */
package com.ibm.au.optim.suro.docloud.util;

import com.ibm.au.optim.suro.model.entities.RunLogEntry;
import com.ibm.au.optim.suro.util.StringUtils;

import com.ibm.icu.text.DateFormat;
import com.ibm.optim.oaas.client.job.model.JobLogRecord;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;
import java.text.ParseException;

/**
 * Class<b>CplexLogFileParser</b>. File reader for parsing well-formed CPLEX 
 * Log Files into structured fields. A user-specified date formatter should 
 * match the date format being output by the CPLEX or DOcloud log generator.
 */
public class CplexLogFileParser extends BufferedReader {

    /**
     * A {@link Logger} instance that is used to collect all the log messages
     * generated by instances of this class and route them to the appropriate
     * logging listeners.
     */
    private static final Logger LOGGER = LoggerFactory.getLogger(CplexLogFileParser.class);

    /**
     * A {@link DateFormat} instance the provides information about the format
     * in which the date and time information are encoded into the log file
     * received through the log stream.
     */
    private DateFormat logDateFormat;
    
    /**
     * A {@link String} representing the unique identifier of the run that
     * generated to log stream parsed by this instance.
     */
    private String runId;
    /**
     * A {@link Marker} instance that is used to univocally mark the log
     * messages that are read by this parser instance.
     */
    private Marker marker;

    /**
     * Constructs a CPLEX log file parser from a specified reader and date
     * formatter. The receive properly formatted dates, the date formatter
     * should correspond to the CPLEX or DOcloud log generator date format.
     *
     * @param reader 	Reader to parse data from
     * @param format 	Date formatter that matches CPLEX log file date format
     * @param runId		a {@link String} representing the unique identifier of the run that originally triggered the 
     * 					log stream.
     */
    public CplexLogFileParser(Reader reader, DateFormat format, String runId) {
        super(reader);
        this.logDateFormat = format;
        this.runId = runId;
        
        this.marker = MarkerFactory.getMarker("run-" + this.runId);
    }

    /**
     * Creates a dummy reader instance to allow using the parse functionality in a context, where no reader is available.
     *
     * @param format	the format used to parse the date in a line
     * @param runId		a {@link String} representing the unique identifier of the run that originally triggered the 
     * 					log stream.
     */
    public CplexLogFileParser(DateFormat format, String runId) {
        this(new StringReader("ResumeJobLogParser"), format, runId);
    }

    /**
     * Reads and parses the next well-formed CPLEX log entry into a structured
     * object containing CPLEX diagnostic data. This will skip log inputs that
     * do not correspond to CPLEX diagnostic output. When the stream ends or
     * hits end of file, null is returned.
     *
     * @return Structured CPLEX diagnostic entry or null if no more data
     * @throws IOException
     */
    public RunLogEntry parseLine() throws IOException {
        String line;
        while ((line = this.readLine()) != null) {
            RunLogEntry entry = parseLine(line);
            if (entry != null && entry.getGap() != null) {
                return entry;
            }
        }
        return null;
    }

    /**
     * Parses the content of a job log record and returns the result entry.
     * @param record - the job log record from which to extract information
     * @return - the optimisation result entry.
     */
    public RunLogEntry parseLine(JobLogRecord record) {
        return parseLine("[" + logDateFormat.format(record.getDate()) + ", " + record.getLevel() + "] " + record.getMessage());
    }

    /**
     * Parses a line containing date, level and message and returns an optimisation result entry containing the parsed
     * information
     * @param line - the line to parse
     * @return - an optimisation result entry
     */
    public RunLogEntry parseLine(String line) {
    	
    	RunLogEntry entry = null;
    	
    	// we store the original log, so that we can collect it
    	// later if we want.
    	//
    	LOGGER.debug(this.marker, line);
    	
        String[] tokens = parsePrefix(line);
        String date = tokens[0];
        String logContent = tokens[2];

        if (logContent.length() == 80) {
        	
            entry = new RunLogEntry();
            entry.setTime(this.safeParseTimestamp(date));
            entry.setSolution(CplexLogFileParser.parseEntry(logContent, 1, 2).equals("*"));
            entry.setOtherCheck(CplexLogFileParser.parseEntry(logContent, 8, 9).equals("+"));
            entry.setNode(StringUtils.safeParseLong(logContent, 2, 8));
            entry.setNodesLeft(StringUtils.safeParseLong(logContent, 9, 14));
            entry.setObjective(StringUtils.safeParseDouble(logContent, 14, 28));
            entry.setIinf(StringUtils.safeParseLong(logContent, 28, 34));
            entry.setBestInteger(StringUtils.safeParseDouble(logContent, 34, 48));
            entry.setBestBound(StringUtils.safeParseDouble(logContent, 48, 62));
            entry.setTotalIterations(StringUtils.safeParseLong(logContent, 62, 71));
            entry.setGap(StringUtils.safeParseDouble(logContent, 71, 79));
            entry.setRawLine(line);

            if (entry.getGap() == null) {
                
            	LOGGER.warn("Gap is null, skipping log line. [line: " + line + "].");
            	entry = null;
            }
            
        } 
        return entry;
    }

    /**
     * This method parses the prefix section of the log line and extracts the date and time
     * information, the type of log line, and the remaining content, which are returned as
     * an array of 3 {@link String} values.
     *
     * @param line a {@link String} representing the log line received by the live log stream
     *             that has been read by the parser.
     * @return a {@link String} array containing 3 elements, the first is the portion of the
     * prefix containing the date and time information, the second is the portion of
     * the prefix containing the type of log information, and the third is the remaining
     * part of the log line.
     */
    private String[] parsePrefix(String line) {
        // parse the prefix of the normal log messages coming in from DOCloud (Stream)
        int open = line.indexOf('[');
        int close = line.indexOf(']');

        String date = null;
        String type = null;
        String content = line;

        if (open >= 0 && close > 0) {

            String[] prefixTokens = line.substring(open + 1, close).split(",");
            if (prefixTokens.length != 2) {
                LOGGER.error("[Line Prefix Error] " + line);
            }
            date = prefixTokens[0];
            type = prefixTokens[1];
            content = line.substring(close + 1);
        }

        return new String[]{date, type, content};
    }

    /**
     * This function tries to parse the information about time from
     * the given string. If it fails it simply catches the exception
     * generated by the method {@link DateFormat#parse(String)} and
     * returns {@literal null}.
     *
     * @param date a {@link String} containing the textual representation
     *             of date and time.
     * @return a {@link Long} instance representing the value of the time
     * obtained by calling {@link java.util.Date#getTime()} on the parsed
     * instance of {@link java.util.Date} from <i>date</i>, or {@literal null}
     * in case the process generated a {@link ParseException}.
     */
    private Long safeParseTimestamp(String date) {

        try {
            return this.logDateFormat.parse(date).getTime();

        } catch (ParseException pe) {
            // nothing

            LOGGER.warn("Cannot parse date and time information [fragment: " + date + "].", pe);
        }
        return null;
    }

    /**
     * This function extracts the content of the log line that contains information
     * about a specific property of the optimization entry.
     *
     * @param str   a {@link String} representing the log line received by the
     *              parser through the live log stream.
     * @param start an {@literal int} representing the position in the log line
     *              where the information about the entry of interest starts.
     * @param stop  an {@literal int} representing the position in the log line
     *              where the information about the entry of interest ends.
     * @return a {@link String} representing the sub-string containing the entry of
     * interest.
     */
    private static String parseEntry(String str, int start, int stop) {

        return str.substring(start, stop).trim();
    }

}
