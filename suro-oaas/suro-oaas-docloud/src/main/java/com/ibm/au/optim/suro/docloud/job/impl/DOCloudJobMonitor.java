/**
 * Copyright (C) 2015 IBM Corporation
 * All Rights Reserved
 */
package com.ibm.au.optim.suro.docloud.job.impl;

import com.ibm.au.optim.suro.docloud.Constants;
import com.ibm.au.optim.suro.docloud.util.CplexLogFileParser;
import com.ibm.au.optim.suro.model.control.Core;
import com.ibm.au.optim.suro.model.control.RunController;
import com.ibm.au.optim.suro.model.control.job.JobExecutor;
import com.ibm.au.optim.suro.model.control.job.JobMonitor;
import com.ibm.au.optim.suro.model.entities.RunDetails;
import com.ibm.au.optim.suro.model.entities.RunLogEntry;
import com.ibm.au.optim.suro.model.entities.Run;
import com.ibm.au.optim.suro.model.entities.JobStatus;
import com.ibm.au.optim.suro.model.entities.RunStatus;
import com.ibm.au.optim.suro.model.store.RunDetailsRepository;
import com.ibm.au.optim.suro.model.store.RunRepository;
import com.ibm.au.jaws.web.core.runtime.Environment;
import com.ibm.optim.oaas.client.OperationException;
import com.ibm.optim.oaas.client.job.*;
import com.ibm.optim.oaas.client.job.model.Job;
import com.ibm.optim.oaas.client.job.model.JobFailureInfo;
import com.ibm.optim.oaas.client.job.model.JobSolveStatus;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.io.InterruptedIOException;
import java.io.Reader;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

/**
 * Class <i>DOCloudJobMonitor</i>. It implements the {@link JobCallback} interface defined
 * by the DOCloud Java API. This class handles state changes and associated persistence 
 * between the DOcloud API and the cached data in the repository. It also manages the 
 * parsing of the real time log stream attached to the remote job associated to the {@link 
 * Run} instance configured with the instance, if running.
 *
 */
public class DOCloudJobMonitor implements JobCallback, JobMonitor {

	/**
	 * A {@link Logger} instance that is used to collect all the log messages
	 * generated by instances of this class and route them to the appropriate
	 * logging listeners.
	 */
	private static final Logger LOGGER = LoggerFactory.getLogger(DOCloudJobMonitor.class);


	/**
	 * This {@link ExecutorService} instance is used to schedule and run all the 
	 * instances of {@link LogMonitor} that will read the live log stream of the
	 * remote jobs that are associated to {@link Run} instances.
	 */
    protected static final ExecutorService logMonitorExecutor = Executors.newCachedThreadPool();

    /**
     * A {@literal long} instance representing the last time the optimization
     * results have been updated. This variable is set to the current time so
     * that when the thread of the monitor starts we have a reasonable reference
     * to compute the update interval.
     */
    private long lastUpdate = System.currentTimeMillis();

	/**
	 * A {@link Reader} implementation that is used to access the content of the
	 * content of the live log stream attached to the remote job associated to
	 * the {@link Run} instance configured with this instance of {@link DOCloudJobMonitor}.
	 * 
	 */
	private Reader liveLogStream;

	/**
	 * A {@link Future} that represents the handle to the thread that is associated
	 * to the {@link LogMonitor} instance submitted to the scheduler to read the
	 * live log stream. This is necessary to be able to terminate the execution of
	 * the monitor if necessary.
	 */
    protected Future<?> monitor;

	/**
	 * A {@link RunRepository} implementation that represents the interface to the
	 * repository that manages the {@link Run} instance.
	 */
    protected RunRepository runRepository;


    /**
     * Holds an instance of the run controller.
     */
	protected RunController runController;

	/**
	 * A {@link RunDetailsRepository} implementation that represents the
	 * interface to the reposuitory that stores and manages all the results for 
	 * each {@link Run}.
	 */
    protected RunDetailsRepository runDetailsRepository;
	
	/**
	 * A {@link RunDetails} representing the collection of results that are
	 * collected while parsing the live log stream attached to the remote job associated
	 * to the configured {@link Run}.
	 */
    protected RunDetails runDetails;

	/**
	 * The ID of a run instance that represents the {@link com.ibm.au.optim.suro.model.strategy.Strategy} execution that this
	 * instance of {@link DOCloudJobMonitor} is monitoring.
	 */
    protected String runId;

    /**
     * The job ID that is currently used to identify the thread on DOCloud for the current run
     */
    protected String jobId;


	/**
	 * Flag to store if the run / job was aborted or not
	 */
	protected boolean isAbortRun = false;

	/**
	 * A {@link JobRequest} instance containing the submission information that triggered
	 * the remote job that is associated to the configured {@link Run} instance.
	 */
    protected JobClient jobClient;

    /**
     * The job executor who created this monitor.
     */
    protected JobExecutor executor;

    /**
     * Holds an instance of the core for general controller access (and better access to the related run)
     */
    protected Core core;

    /**
     * Indicates if the job is running. Will be initialized with true and only set to false once the job is aborted,
     * finished or ends with an error. Reading this flag will prevent log reader exceptions for trying to read on a
     * finished job.
     */
    protected boolean jobRunning = true;


	/**
	 * This constructor initialises the {@link DOCloudJobMonitor} instance with the given information.
	 *
	 * @param exec				a {@link JobExecutor} instance used to control the execution of the job. 
	 * @param client			a {@link JobClient} instance used to access DOCloud.
	 * @param runId				a {@link Run} instance representing the specific execution of a {@link
	 * 							com.ibm.au.optim.suro.model.strategy.Strategy}.
	 * @param environment		a {@link Environment} implementation that is used to retrieve the
	 * 							configured {@link RunRepository} and {@link RunDetailsRepository}
	 * 							implementations.
	 */
    protected DOCloudJobMonitor(JobExecutor exec, JobClient client, String runId, Environment env) {
    	
    	this.runId = runId;
		this.jobClient = client;
		this.executor = exec;
		
		// save repositories and controllers
		this.core = (Core) env.getAttribute(Core.CORE_INSTANCE);
		this.runRepository = (RunRepository) env.getAttribute(RunRepository.RUN_REPOSITORY_INSTANCE);
		this.runController = (RunController) env.getAttribute(RunController.RUN_CONTROLLER_INSTANCE);
		this.runDetailsRepository = (RunDetailsRepository) env.getAttribute(RunDetailsRepository.DETAILS_REPOSITORY_INSTANCE);

    }

	/**
	 * Initializes an instance of {@link DOCloudJobMonitor} with the given parameters.
	 * 
	 * @param exec				a {@link JobExecutor} instance used to control the execution of the job. 
	 * @param client			a {@link JobClient} instance used to access DOCloud.
	 * @param runId				a {@link Run} instance representing the specific execution of a {@link
	 * 							com.ibm.au.optim.suro.model.strategy.Strategy}.
	 * @param liveLogStream		a {@link Reader} implementation provides the capability of accessing the
	 * 							live log stream attached to the remote job associated to <i>run</i>.
	 * @param environment		a {@link Environment} implementation that is used to retrieve the
	 * 							configured {@link RunRepository} and {@link RunDetailsRepository}
	 * 							implementations.
	 */
	public DOCloudJobMonitor(JobExecutor exec, JobClient client, String runId, Reader liveLogStream, Environment environment) {
		this(exec, client, runId, environment);
		LOGGER.debug("Creating new job monitor for run " + runId);
		

		// store the log reader
		this.liveLogStream = liveLogStream;

        
        // create initial result item
		this.runDetails = new RunDetails();
		this.runDetailsRepository.addItem(runDetails);
		this.runDetails.setRunId(runId);

        LogMonitor mon = new LogMonitor(this.runId);
		this.monitor = logMonitorExecutor.submit(mon);
		LOGGER.debug("Submitted job monitor for run " + runId);
	}


    @Override
    public void cancel() {
        this.monitor.cancel(true);
    }

    @Override
    public Run getRun() {
    	
        return this.runController.getRun(this.runId);
        
    }

    @Override
	public JobExecutor getJobExecutor() {
		return this.executor;
	}

	/**
	 * Retrieves the current monitor object that runs in the background monitoring the job progress.
	 * @return
	 */
	public Future<?> getMonitor() {
		return this.monitor;
	}

	/**
	 * This method is a callback that is invoked when a {@link Job} is created
	 * on DOCloud. The method logs the event, sets the unique identifier of the
	 * job in the configured {@link Run} instance so that the two components
	 * can be linked together, persists the updated {@link Run} instance into
	 * the repository (if needed), and notifies the listeners attached to the
	 * bus about the event.
	 * 
	 * @param jr	a {@link JobResponse} instance that contains information about
	 * 				the {@link Job} instance related to the event and also some
	 * 				other information about the event.
	 */
	@Override
	public void created(JobResponse jr) {
		LOGGER.debug("========================= CREATED =======================");

		// fetch the job ID and store it at the executor and monitor instance
        if (jr != null) {
            this.jobId = jr.getJobId();
            this.getJobExecutor().setCurrentJobId(jobId);
        }

		DOCloudJobMonitor.debug(jobId, "Job Created with ID " + jobId);
		
		synchronized (this.runRepository) {
            Run run = this.getRun();
			// set job state
			this.runController.setJobStatus(run, JobStatus.CREATED);

			// handle run state (for resumed jobs that haven't been submitted or new runs that are queued
			if ((RunStatus.RESUME == run.getStatus()) || (RunStatus.QUEUED == run.getStatus())) {
				// only update in happy path
				this.runController.setRunStatus(run, RunStatus.CREATE_JOB);
			}

			if (this.jobId != null) {
				// set job id
				run.setJobId(jobId);
				this.runRepository.updateItem(run);
			}
        }

        // notify any clients connected (web UI)
		this.getJobExecutor().notifyRunEvent(this.runId);
	}

	/**
	 * This method is a callback that is invoked when a {@link Job} is submitted
	 * on DOCloud. The method logs the event, persists the updated {@link Run}
	 * instance into the repository (if needed), and notifies the listeners attached 
	 * to the bus about the event.
	 * 
	 * @param jr	a {@link JobResponse} instance that contains information about
	 * 				the {@link Job} instance related to the event and also some
	 * 				other information about the event.
	 */
    @Override
	public void submitted(JobResponse jr) {
		LOGGER.debug("========================= SUBMITTED =======================");
		
		DOCloudJobMonitor.debug(jr.getJobId(), "Job Submitted");
        synchronized (this.runRepository) {
            Run run = this.getRun();
            this.runController.setJobStatus(run, JobStatus.SUBMITTED);
        }

        // write to notifier bus
		this.getJobExecutor().notifyRunEvent(this.runId);
	}

	/**
	 * This method is a callback that is invoked when a {@link Job} transit to the
	 * running state on DOCloud. The method logs the event, persists the updated 
	 * {@link Run} instance into the repository (if needed), and notifies the listeners
	 * attached to the bus about the event.
	 * 
	 * @param jr	a {@link JobResponse} instance that contains information about
	 * 				the {@link Job} instance related to the event and also some
	 * 				other information about the event.
	 */
    @Override
	public void running(JobResponse jr) {
		
    	LOGGER.debug("========================= RUNNING =======================");
    	
		DOCloudJobMonitor.debug(jobId, "Job Running");
        
		synchronized (this.runRepository) {
        	
            Run run = this.getRun();
            
            if ((run.getStatus() != RunStatus.ABORTING) && (run.getStatus() != RunStatus.ABORTED)) {
            	
                this.runController.setRunStatus(run, RunStatus.PROCESSING);
                
                this.runController.setJobStatus(run, JobStatus.RUNNING);
                
            } else {
            	
                this.getJobExecutor().abort();
            }
        }
		this.getJobExecutor().notifyRunEvent(this.runId);
	}

	/**
	 * This method is a callback that is invoked when the results of a {@link Job} are
	 * fully processed. The method logs the event, retrieves the information stored in
	 * the result files generated by the job, processes these results and persists the 
	 * updated {@link Run} instance into the repository (if needed). It then notifies 
	 * the listeners attached to the bus about the event.
	 * 
	 * @param jr	a {@link JobResponse} instance that contains information about
	 * 				the {@link Job} instance related to the event and also some
	 * 				other information about the event.
	 */
    @Override
	public void processed(JobResponse jr) {
		
    	LOGGER.debug("========================= PROCESSED =======================");
		DOCloudJobMonitor.debug(jobId, "Job Processed");
        
		synchronized (this.runRepository) {
			
            Run run = this.getRun();
        
            this.runController.setJobStatus(run, JobStatus.PROCESSED);
			this.runController.setRunStatus(run, RunStatus.COLLECTING_RESULTS);
        }

		// fetch logs
        this.getJobExecutor().collectResults(this.getRun());
		this.getJobExecutor().notifyRunEvent(this.runId);
	}


	/**
	 * This method is a callback that is invoked when a {@link Job} running on DOCloud
	 * is interrupted. The method logs the event, process the results (if the job has
	 * produced any partial results), persists the updated {@link Run} instance into the 
	 * repository (if needed), and notifies the listeners attached to the bus about the 
	 * event.
     *
     * This method doesn't rely on the JobResponse to be available, so it can be used by
     * the DOCloudResumeJobMonitor.
	 * 
	 * @param jr	a {@link JobResponse} instance that contains information about
	 * 				the {@link Job} instance related to the event and also some
	 * 				other information about the event.
	 */
    @Override
	public void interruption(JobResponse jr) {
    	
		LOGGER.debug("========================= INTERRUPTED =======================");
		DOCloudJobMonitor.debug(jobId, "Job Interrupted");

		// update run and job state
		synchronized (this.runRepository) {
			Run run = this.getRun();

			if (RunStatus.ABORTING == run.getStatus()) {
				this.isAbortRun = true;
			}
			this.runController.setRunStatus(run, RunStatus.COLLECTING_RESULTS);
		}

		Run run = this.getRun();
		
        // retrieve job object and process results
        Job job;
		try {
            job = this.getJob(jr);
			this.getJobExecutor().collectResults(run);

			// update log debug info
			synchronized (this.runDetailsRepository) {
				
				// [CV] NOTE: old code, now we store this information into the details
				//            object because it is a more appropriate place to store
				//            backend specific data.
				//
				// Run run = getRun();
				// run.setInterruptionStatus(job.getInterruptionStatus().toString());
				// runRepository.updateItem(run);
				
				this.runDetails.setAttribute("docloud_interruption_status", job.getInterruptionStatus().toString());
				this.runDetailsRepository.updateItem(this.runDetails);
			
			}
		} catch (Exception e) {
			
			DOCloudJobMonitor.error(jobId, "Error while handling job interruption", e);
			
			synchronized (this.runRepository) {
				
				run = this.getRun();
				this.runController.setRunStatus(run, RunStatus.FAILED);
			}
		}

        // notifier bus
		this.getJobExecutor().notifyRunEvent(this.runId);
	}


	/**
	 * This method is a callback that is invoked when a {@link Job} fails its execution
	 * on DOCloud. This could occur either because the job fails, or it is terminated by
	 * the client. The method logs the event, retrieves the information about the job 
	 * failure and attaches them to the {@link Run} instance, persists the updated 
	 * {@link Run} instance into the repository (if needed), and notifies the listeners
	 * attached to the bus about the event.
	 * 
	 * @param jr	a {@link JobResponse} instance that contains information about
	 * 				the {@link Job} instance related to the event and also some
	 * 				other information about the event.
	 */
    @Override
	public void failed(JobResponse jr) {
		LOGGER.debug("========================= FAILED =======================");
        try {
            Job job = getJob(jr);
			if (job != null) {
				LOGGER.error("Job " + this.jobId + " failed: " + job.getFailureInfo().getMessage());
				// process job failure information
				JobFailureInfo failure = job.getFailureInfo();

				// store the failure information
				synchronized (this.runRepository) {
					
					Run run = getRun();
					// update failure and solve status
					// run.setFailure(failure.getType().toString(), failure.getMessage());
					run.setSolveStatus(JobSolveStatus.UNKNOWN.toString());
					this.runRepository.updateItem(run);
				}
				
				synchronized (this.runDetailsRepository) {
					
					this.runDetails.setAttribute(Constants.DOCLOUD_ATTRIBUTE_FAILURE_TYPE, failure.getType().toString());
					this.runDetails.setAttribute(Constants.DOCLOUD_ATTRIBUTE_FAILURE_MESSAGE, failure.getMessage());
					
					this.runDetailsRepository.updateItem(this.runDetails);
				}
			}

            getJobExecutor().runFailed(this.runId);
        } catch (Exception e) {
            LOGGER.error("Exception occurred while the callback for failed() was executed.", e);
        }

	}


	/**
	 * This method is a callback that is invoked when a {@link Job} running on DOCloud
	 * generates an exception. The method logs the event, retrieves the exception information
	 * and attaches the exception details to the {@link Run} instance, it persists it into the 
	 * repository (if needed), and notifies the listeners attached to the bus about the event.
	 * It then deletes the {@link Job} on DOCloud.
	 * 
	 * @param jr	a {@link JobResponse} instance that contains information about
	 * 				the {@link Job} instance related to the event and also some
	 * 				other information about the event.
	 * 
	 * @param ex	a {@link Exception} instance that represents the error occurred on the
	 * 				remote end while executing the job.
	 */
    @Override
	public void exception(JobResponse jr, Exception ex) {
    	
		LOGGER.debug("========================= EXCEPTION =======================");
		DOCloudJobMonitor.error(jobId, "Received job exception", ex);
		
        synchronized (this.runRepository) {
            runController.setJobStatus(getRun(), JobStatus.EXCEPTION);
            runController.setRunStatus(getRun(), RunStatus.FAILED);
        }

        if (jobId != null) {
        	
			// If document has a job id, assume we're into processing already.
			// Mark the run as a failure
            synchronized (this.runRepository) {
            	
                Run run = this.getRun();
                
                // [CV] NOTE: this information is now in the runDetails entity because it is
                //            specific to a given optimisation backend.
                //
                // run.setException(ex.getClass().getSimpleName(), ex.getLocalizedMessage());
                run.setSolveStatus(JobSolveStatus.UNKNOWN.toString());
                
                // [CV] NOTE: this can be computed from the <i>status</i> property.
                //
                // run.setFinished(true);
                this.runRepository.updateItem(run);
            }
            
            synchronized(this.runDetailsRepository) {
            	
            	this.runDetails.setAttribute(Constants.DOCLOUD_ATTRIBUTE_EXCEPTION_TYPE, ex.getClass().getSimpleName());
            	this.runDetails.setAttribute(Constants.DOCLOUD_ATTRIBUTE_EXCEPTION_MESSAGE, ex.getLocalizedMessage());
            	
            	this.runDetailsRepository.updateItem(this.runDetails);
            }

			// notifier bus
			this.getJobExecutor().notifyRunEvent(this.runId);
            // cleanup job
			core.getJobController().deleteJob(jobId);
		}
		
		this.finished();
		error(jobId, "Job finished with Exception", ex);
	}


	/**
	 * This method is a callback that is invoked when a {@link Job} successfully completes
	 * its execution on DOCloud. The method logs the event, sets the completed flag to 
	 * {@literal true} in the {@link Run} instance and persist it into the repository. It
	 * then notifies the listeners attached to the bus about the event and stops the {@link
	 * LogMonitor} that was attached to live log stream.
	 * 
	 * @param jr	a {@link JobResponse} instance that contains information about
	 * 				the {@link Job} instance related to the event and also some
	 * 				other information about the event.
	 */
    @Override
	public void completed(JobResponse jr) {

		LOGGER.debug("========================= COMPLETED =======================");

        try {
            Job job = getJob(jr);

            // update run data
            synchronized (this.runRepository) {
                Run run = getRun();
				// handle job status
				runController.setJobStatus(run, JobStatus.COMPLETED);

				// handle run status
				if (!isAbortRun) {
					runController.setRunStatus(run, RunStatus.COMPLETED);
				} else {
					runController.setRunStatus(run, RunStatus.ABORTED);
				}

				// finalise run record
				if (job != null) {
					
					run.setRunTime(job.getEndedAt().getTime() - job.getStartedAt().getTime());
					
					// [CV] NOTE: we do not need to do this anymore.
					//			  This property can be synthetically computed
					//            from the value of the status property.
					//
					// run.setFinished(true);
					this.runRepository.updateItem(run);
				}
            }

            // notify clients
            if (isAbortRun) {
                getJobExecutor().runAborted(this.runId);
            } else {
                getJobExecutor().runCompleted(this.runId);
            }

			// cancels log monitor and flags monitor as finished
            finished();
            // cleanup job executor (and other components)
            this.core.completeRun(runId);


            debug(jobId, "Job Finished");
        } catch (Exception e) {
            error(jobId, "Error occurred while trying to complete the job.", e);
        }
	}


    /**
     * Returns the job associated with this monitor. If the passed parameter (JobResponse) is null, the client will be
     * used to retrieve the job from DOCloud. Otherwise the job will be read directly from the job response.
     *
     * @param jr - an optional job response
     * @return - the job provided by the JobResponse or retrieved by the job client
     *
     * @throws OperationException - technical issues with DOCloud
     * @throws JobNotFoundException - job doesn't exist anymore
     */
    protected Job getJob(JobResponse jr) throws OperationException, JobNotFoundException {
        if (jr == null) {
            return jobClient.getJob(jobId);
        } else {
            return jr.getJob();
        }
    }



	/**
	 * This method terminates the {@link LogMonitor} instance attached to the live log
	 * stream of the {@link Job} attached to the given response.
	 */
	protected void finished() {
		LOGGER.debug("Finished job monitoring.");
        // set the monitor to finished
		setJobRunning(false);
        // cleanup the job in DOCloud
        core.getJobController().deleteJob(jobId);
        // cancel any monitoring thread
		monitor.cancel(true);
        commitChanges(true);
	}

	
	/**
	 * Wrapper method for {@link Logger#error(String,Throwable)} that checks whether
	 * the error level is enabled before invoking the method with a formatted message
	 * that also encodes the information about the job identifier in the format:
	 * [<i>jobId<i>] <i>message</i>.
	 * 
	 * @param jobId		a {@link String} representing the identifier of the job which
	 * 					the error is related to.	
	 * @param message	a {@link String} representing the additional text message to
	 * 					format the error message with.
	 * 
	 * @param t			a {@link Throwable} instance representing the original cause
	 * 					for this error message.
	 */
	private static void error(String jobId, String message, Throwable t) {
		if (LOGGER.isErrorEnabled()) {
			LOGGER.error(String.format("[MONITOR] [%s] %s", jobId, message), t);
		}
	}
	
	/**
	 * Wrapper method for {@link Logger#warn(String,Throwable)} that checks whether
	 * the warning level is enabled before invoking the method with a formatted message
	 * that also encodes the information about the job identifier in the format:
	 * [<i>jobId<i>] <i>message</i>.
	 * 
	 * @param jobId		a {@link String} representing the identifier of the job which
	 * 					the warning is related to.	
	 * @param message	a {@link String} representing the additional text message to
	 * 					format the warning message with.
	 * 
	 * @param t			a {@link Throwable} instance representing the original cause
	 * 					for this warning message.
	 */
	private static void warn(String jobId, String message, Throwable t) {
		if (LOGGER.isWarnEnabled()) {
			LOGGER.warn(String.format("[MONITOR] [%s] %s", jobId, message), t);
		}
	}

	
	/**
	 * Wrapper method for {@link Logger#debug(String)} that composes formatted message
	 * that also encodes the information about the job identifier in the format:
	 * [<i>jobId<i>] <i>message</i>.
	 * 
	 * @param jobId		a {@link String} representing the identifier of the job which
	 * 					the message is related to.	
	 * @param message	a {@link String} representing the additional text message to
	 * 					format the debug message with.
	 */
	private static void debug(String jobId, String message) {
		LOGGER.debug(String.format("[MONITOR] [%s] %s", jobId, message));
	}


	/**
	 * Prints out a debug message with an exception
	 * @param jobId - the id of the job
	 * @param message - the debug message
	 * @param t - an exception that will be logged as well.
	 */
	private static void debug(String jobId, String message, Throwable t) {
		LOGGER.debug(String.format("[MONITOR] [%s] %s", jobId, message), t);
	}


	/**
	 * Setter for the job running flag.
	 * @param jobRunning - the new value for the flag.
	 */
    public void setJobRunning(boolean jobRunning) {
        this.jobRunning = jobRunning;
    }

	/**
	 * Getter for the job running flag.
	 * @return - whether the job monitored by this monitor is currently running.
	 */
    public boolean isJobRunning() {
        return this.jobRunning;
    }

    /**
     * Commits optimization log local updates log to the database. If
     * {@code force = false}, then the updates will be committed if and
     * only if the the time elapsed since the last update exceeds the
     * default update interval.
     *
     * @param force if updates should be committed to DB regardless of
     * 	 			update interval.
     */
    protected void commitChanges(boolean force) {
        if (force || (this.lastUpdate + LogMonitor.DB_UPDATE_INTERVAL < System.currentTimeMillis())) {
            debug(jobId, "Committing Changes for Job Monitor");
            runDetailsRepository.updateItem(runDetails);
            this.lastUpdate = System.currentTimeMillis();
        }
    }



    /**
     * Class <b>LogMonitory</b>. This class implements {@link Runnable} and defines
     * real-time job monitor to read optimization log entries from "live" CPLEX log
     * file. New entries are appended and persisted to a DB on a given update interval.
     * New entries are also published to the notification bus for push to listening
     * clients.
     */
    private class LogMonitor implements Runnable {

        /**
         * Interval to commit optimization log updates to DB, in milliseconds
         */
        private static final int DB_UPDATE_INTERVAL = 10000; // 10 second update

        /**
         * A {@link String} representing the unique identifier of the {@link Run}
         * instance that generated the execution that this instance of {@link LogMonitor}
         * is observing by monitoring the generated logs.
         */
        protected String runId;

        /**
         * Creates an instance of the {@link LogMonitor} class.
         */
        public LogMonitor(String runId) {
        	
        	this.runId = runId;
        }


        /**
         * This is the main method of the {@link LogMonitor} which is executed in the
         * thread. The method creates an instance of {@link CplexLogFileParser} and
         * attaches it to the live log stream configured with the instance of the
         * {@link DOCloudJobMonitor} that contains this class. It then enters a reading
         * loop where each line is processed and if the time interval surpasses the
         * default update interval it pushes to the notification bus the information
         * about parsed {@link RunLogEntry} instance.
         */
        @Override
        public void run() {
            // job ID not available yet
            debug(null, "Starting Log Monitor");

            CplexLogFileParser logFileParser = null;
            try {
                logFileParser = new CplexLogFileParser(liveLogStream, Constants.DOCLOUD_DATE_FORMATTER, this.runId);

                RunLogEntry entry = null;
                // Read entries from the CPLEX log file and add them to the optimization runtime result log DB entry
                // TODO: check we can parse the entry and figure out when to set the jobRunning flag to prevent exception below
                while (isJobRunning() && (entry = logFileParser.parseLine()) != null) {

                    // TODO decide if this is the correct methodology :)
                    // Override the time on the DOcloud server runtime with a local time to avoid clock disparity in real-time graphs
                    entry.setTime(System.currentTimeMillis());

                    if (runDetails.addEntry(entry)) {
                        // Send event to notification bus to update listening clients
                        getJobExecutor().notifyOptimEvent(runId, entry);

                        // Commit changes to DB (if within update interval)
                        commitChanges(false);
                    }
                }

            } catch (InterruptedIOException iioe) {
                // if interrupted, the job is finished
                debug(jobId, "Closed input stream signaling the end of the job in DOCloud after completed() callback.", iioe);

            } catch (IOException ioe) {
                warn(jobId, "Exception while reading optimization log entry", ioe);
			} finally {
                IOUtils.closeQuietly(logFileParser);
            }

            debug(runId, "Exiting Job Log Monitor");
        }


    }


}