package com.ibm.au.optim.suro.model.entities.mapping;

import org.junit.Assert;
import org.junit.Test;

import com.ibm.au.optim.suro.model.entities.mapping.MappingSource;
import com.ibm.au.optim.suro.model.entities.mapping.MappingSpecification;
import com.ibm.au.optim.suro.model.entities.mapping.ValueMapping;


/**
 * Class <b>MappingSourceTest</b>. This class tests the implemented behaviour
 * of the {@link MappingSource} class. The class defines a source for the
 * mapping and provides information on how to transform and compose that 
 * informatioi into a portion of the table view generated by the mapping.
 * 
 * @author Peter Ilfrich and Christian Vecchiola
 */
public class MappingSourceTest {

	
	/**
	 * This method tests the implemented behaviour of the constructor, which
	 * takes as an argument a single parameter representing the pointer to the
	 * item in the output generated by the optimisation backend from where to
	 * source data. This argument is expected to not to be {@literal null}.
	 */
    @Test
    public void testConstructor() {
    	
    	// Test 1. Standard initialisation.
    	//
    	String expected = "key";

        MappingSource source = new MappingSource(expected);
        String actual = source.getSolutionKey();
        Assert.assertEquals(expected, actual);
        
        // all the other properties should be null.
        //
        Assert.assertNull(source.getRow());
        Assert.assertNull(source.getValue());
        Assert.assertNull(source.getColumn());
        
        Assert.assertNull(source.getValueKeys());
        
        Assert.assertNull(source.getColumnLabels());
        Assert.assertNull(source.getColumnEntryKeys());
        
        Assert.assertNull(source.getRowLabels());
        Assert.assertNull(source.getRowEntryKeys());
        
        
        // Test 2. How do we deal with a null?
        
        try {
        	
        	source = new MappingSource(null);
        	Assert.fail("MappingSource.MappingSource(null) should throw IllegalArgumentException.");
        	
        } catch(IllegalArgumentException ilex) {
        	
        	// ok, good to go...
        }
    }
    
    /**
     * This method tests the implemented behaviour of the getter and setter for
     * the <i>solutionKey</i> property. The getter is expected to return either
     * the value originally passed to the constructor of the instance or the
     * value set with the setter. It is not possible to assign a {@literal null}
     * value.
     */
    @Test
    public void testGetSetSolutionKey() {
    
    	String expected = "key";
    	
    	// Test 1. The getter should return the default value
    	//		   which in this case is the one passed to the
    	//         constructor.
    	MappingSource source = new MappingSource(expected);
    	String actual = source.getSolutionKey();
    	Assert.assertEquals(expected, actual);
    	
    	// Test 2. The getter should return what we set with the
    	//         setter.
    	expected = "anotherKey";
    	source.setSolutionKey(expected);
    	actual = source.getSolutionKey();
    	Assert.assertEquals(expected, actual);
    	
    	// Test 3. The setter should throw exception when trying
    	//		   to set a null value.
    	
    	try {
        	
        	source.setSolutionKey(null);
        	Assert.fail("MappingSource.setSolutionKey(null) should throw IllegalArgumentException.");
        	
        } catch(IllegalArgumentException ilex) {
        	
        	// ok, good to go...
        }
    	
    }
    
    
    /**
     * This method tests the implemented behaviour of the getter and setter for
     * the <i>value</i> property. The getter is expected to return either the 
     * default value ({@literal null} or the value set with the setter. There are
     * no restriction on the value that can be assigned.
     */
    @Test
    public void testGetSetValue() {
    	
        MappingSource source = new MappingSource("key");

        // Test 1. sunny day testing.
        //
        ValueMapping expected = new ValueMapping(new String[] { "label" });
        source.setValue(expected);
        ValueMapping actual = source.getValue();
        Assert.assertEquals(expected, actual);

        // Test 2. with null
        //
        source.setValue(null);
        Assert.assertNull(source.getValue());
    }

    
    /**
     * This method tests the implemented behaviour of the getter and setter for
     * the <i>row</i> property. The getter is expected to return either the 
     * default value ({@literal null} or the value set with the setter. There are
     * no restriction on the value that can be assigned.
     */
    @Test
    public void testGetSetRow() {
    	
        MappingSource source = new MappingSource("key");

        // Test 1. sunny day testing.
        //
        MappingSpecification expected = new MappingSpecification(new String[] { "label" }, new String[] { "entry"} );
        source.setRow(expected);
        MappingSpecification actual = source.getRow();
        Assert.assertEquals(expected, actual);

        // Test 2. with null
        //
        source.setRow(null);
        Assert.assertNull(source.getRow());
    }
    
    /**
     * This method tests the implemented behaviour of the getter and setter for
     * the <i>column</i> property. The getter is expected to return either the 
     * default value ({@literal null} or the value set with the setter. There are
     * no restriction on the value that can be assigned.
     */
    @Test
    public void testGetSetColumn() {
    	
        MappingSource source = new MappingSource("key");

        // Test 1. sunny day testing.
        //
        MappingSpecification expected = new MappingSpecification(new String[] { "label" }, new String[] { "entry"} );
        source.setColumn(expected);
        MappingSpecification actual = source.getColumn();
        Assert.assertEquals(expected, actual);

        // Test 2. with null
        //
        source.setColumn(null);
        Assert.assertNull(source.getColumn());
    }


    /**
     * This method tests the implemented behaviour of {@link MappingSource#getRowLabels()}.
     * Being this a convenience method to access {@link MappingSpecification#getLabels()}, 
     * it  should return the same value that is returned by calling that method on the instance 
     * that is returned by {@link MappingSource#getRow()}. When this one is {@literal null}, 
     * it should return {@literal null}.
     */
    @Test
    public void testGetRowLabels() {
    	
        MappingSource source = new MappingSource("key");
        
        // Test 1. by default it is null, because row it
        //         is null.
        //
        Assert.assertNull(source.getRowLabels());
        
        // Test 2. We assign row with non-null values.
        //
        String[] expected = new String[] { "Tony Stark", "Steve Rogers", "Hank Pym" };
        MappingSpecification row = new MappingSpecification(expected, null);
        source.setRow(row);
        String[] actual = source.getRowLabels();
        MappingSpecification expectedRow = source.getRow();
        Assert.assertArrayEquals(expectedRow.getLabels(), actual);
        
        // Test 2. row is null.
        //
        row = null;
        source.setRow(row);
        actual = source.getRowLabels();
        Assert.assertNull(actual);
        
        
        // Test 3. null and the original labels are null.
        //
        row = new MappingSpecification((String[]) null, (String[]) null);
        source.setRow(row);
        actual = source.getRowLabels();
        Assert.assertNull(actual);
        
        
    }

    /**
     * This method tests the implemented behaviour of {@link MappingSource#getColumnLabels()}.
     * Being this a convenience method to access {@link MappingSpecification#getLabels()}, it 
     * should return the same value that is returned by calling that method on the instance that
     * is returned by {@link MappingSource#getColumn()}. When this one is {@literal null}, it 
     * should return {@literal null}.
     */
    @Test
    public void testGetColumnLabels() {
    	
        MappingSource source = new MappingSource("key");
        
        // Test 1. by default it is null, because column
        //         is null.
        //
        Assert.assertNull(source.getColumnLabels());
        
        // Test 2. We assign column with non-null values.
        //
        String[] expected = new String[] { "Tony Stark", "Steve Rogers", "Hank Pym" };
        MappingSpecification column = new MappingSpecification(expected, null);
        source.setColumn(column);
        String[] actual = source.getColumnLabels();
        MappingSpecification expectedColumn = source.getColumn();
        Assert.assertArrayEquals(expectedColumn.getLabels(), actual);
        
        // Test 2. column is null.
        //
        column = null;
        source.setColumn(column);
        actual = source.getColumnLabels();
        Assert.assertNull(actual);
        
        
        // Test 3. null and the original labels are null.
        //
        column = new MappingSpecification((String[]) null, (String[]) null);
        source.setColumn(column);
        actual = source.getColumnLabels();
        Assert.assertNull(actual);
    }


    /**
     * This method tests the implemented behaviour of {@link MappingSource#getRowEntryKeys()}.
     * Being this a convenience method to access {@link MappingSpecification#getEntryKeys()}, it 
     * should return the same value that is returned by calling that method on the instance that
     * is returned by {@link MappingSource#getRow()}. When this one is {@literal null}, it should
     * return {@literal null}.
     */
    @Test
    public void testGetRowEntryKeys() {
    	
    	
        MappingSource source = new MappingSource("key");
        
        // Test 1. by default it is null, because column
        //         is null.
        //
        Assert.assertNull(source.getRowEntryKeys());
        
        // Test 2. We assign column with non-null values.
        //
        String[] expected = new String[] { "Tony Stark", "Steve Rogers", "Hank Pym" };
        MappingSpecification row = new MappingSpecification(expected, null);
        source.setRow(row);
        String[] actual = source.getRowEntryKeys();
        MappingSpecification expectedRow = source.getRow();
        Assert.assertArrayEquals(expectedRow.getEntryKeys(), actual);
        
        // Test 2. column is null.
        //
        row = null;
        source.setRow(row);
        actual = source.getRowEntryKeys();
        Assert.assertNull(actual);
        
        
        // Test 3. null and the original labels are null.
        //
        row = new MappingSpecification((String[]) null, (String[]) null);
        source.setRow(row);
        actual = source.getRowEntryKeys();
        Assert.assertNull(actual);
    }

    /**
     * This method tests the implemented behaviour of {@link MappingSource#getColumnEntryKeys()}.
     * Being this a convenience method to access {@link MappingSpecification#getEntryKeys()}, it 
     * should return the same value that is returned by calling that method on the instance that
     * is returned by {@link MappingSource#getColumn()}. When this one is {@literal null}, it 
     * should return {@literal null}.
     */
    @Test
    public void testGetColumnEntryKeys() {
    	
        MappingSource source = new MappingSource("key");
        
        // Test 1. by default it is null, because column
        //         is null.
        //
        Assert.assertNull(source.getColumnEntryKeys());
        
        // Test 2. We assign column with non-null values.
        //
        String[] expected = new String[] { "Tony Stark", "Steve Rogers", "Hank Pym" };
        MappingSpecification column = new MappingSpecification(expected, null);
        source.setColumn(column);
        String[] actual = source.getColumnEntryKeys();
        MappingSpecification expectedColumn = source.getColumn();
        Assert.assertArrayEquals(expectedColumn.getEntryKeys(), actual);
        
        // Test 2. column is null.
        //
        column = null;
        source.setColumn(column);
        actual = source.getColumnEntryKeys();
        Assert.assertNull(actual);
        
        
        // Test 3. null and the original labels are null.
        //
        column = new MappingSpecification((String[]) null, (String[]) null);
        source.setColumn(column);
        actual = source.getColumnEntryKeys();
        Assert.assertNull(actual);
    }
    

    /**
     * This method tests the implemented behaviour of {@link MappingSource#getValueKeys()}.
     * Being this a convenience method to access {@link ValueMapping#getKeys()}, it should
     * return the same value that is returned by calling that method on {@link MappingSource#getValue()}.
     * When this one is {@literal null}, it should return {@literal null}.
     */
    @Test
    public void testGetValueKeys() {
    	
        MappingSource source = new MappingSource("key");
        
        // Test 1. by default it is null, because value
        //         is null.
        //
        Assert.assertNull(source.getColumnEntryKeys());
        
        // Test 2. We assign value with non-null values.
        //
        String[] expected = new String[] { "Tony Stark", "Steve Rogers", "Hank Pym" };
        ValueMapping value = new ValueMapping(expected);
        source.setValue(value);
        String[] actual = source.getValueKeys();
        ValueMapping expectedValue = source.getValue();
        Assert.assertArrayEquals(expectedValue.getKeys(), actual);
        
        // Test 2. value is null.
        //
        value = null;
        source.setValue(value);
        actual = source.getValueKeys();
        Assert.assertNull(actual);
        
        
        // Test 3. null and the original keys are null.
        //
        value = new ValueMapping((String[]) null);
        source.setValue(value);
        actual = source.getValueKeys();
        Assert.assertNull(actual);
    }
    
    /**
     * This method tests the implemented behaviour of {@link  MappingSource#clone()}. The 
     * method is expected to create a deep copy of the properties that defined the mapping,
     * except for those fields that are immutable or value types. Moreover, the clone is
     * also expected to pass the equality test when compared with the original instance. 
     */
    @Test
    public void testClone() {
    	
    	// Test 1. Create a fresh instance and clone it.
    	//
    	
    	MappingSource expected = new MappingSource("avengers");
    	MappingSource actual = expected.clone();
    	Assert.assertFalse(expected == actual);
    	Assert.assertEquals(expected, actual);
    	
    	
    	
    	// Test 2. We create an object tree, and we check that
    	//         the different properties are cloned and are
    	//         not the same reference.
    	ValueMapping expectedValue = new ValueMapping(new String[] {"Iron Man", "Capitan America", "The Hulk", "Thor" });
    	expected.setValue(expectedValue);
    	
    	MappingSpecification expectedRow = new MappingSpecification(new String[] { "Natasha Romanov" }, new String[] { "Black Widow" });
    	expected.setRow(expectedRow);
    	
    	MappingSpecification expectedColumn = new MappingSpecification(new String[] {"Clint Barton"}, new String[] { "Hawkeye" });
    	expected.setColumn(expectedColumn);
    	
    	actual = expected.clone();
    	
    	// different instances, but equals.
    	//
    	Assert.assertFalse(expected == actual);
    	Assert.assertEquals(expected, actual);
    	
    	// different instances, but the equals
    	//
    	Assert.assertFalse(expected.getValue() == actual.getValue());
    	Assert.assertEquals(expected.getValue(), actual.getValue());
    	
    	Assert.assertFalse(expected.getRow() == actual.getRow());
    	Assert.assertEquals(expected.getRow(), actual.getRow());
    	
    	Assert.assertFalse(expected.getColumn() == actual.getColumn());
    	Assert.assertEquals(expected.getColumn(), actual.getColumn());
    	
    	// we do not need to proceed further because the rest is 
    	// either a convenient method or an immutable type.
    	
    }
    
	/**
	 * This method tests the implementation of the {@link MappingSource#equals(Object)} method.
	 * The method is expected to return {@literal true} when compared with itself, or an instance
	 * of the same type that has the same value (e.g. a clone). In all the other cases it is 
	 * expected to return {@literal false}.
	 */
	@Test 
	public void testEquals() {
		
		// Test 1. Obviousness.
		//
		
		MappingSource expected = new MappingSource("x-men");
		Assert.assertTrue(expected.equals(expected));
		
		
		// Test 2. When invoked with null, it should return false.
		//
		Assert.assertFalse(expected.equals(null));
		
		// Test 3. When invoked with a different type it will return false.
		//         (note: the type should be not compatible).
		//
		Assert.assertFalse(expected.equals(new String()));
		
		// Test 4. We make an exact copy of the object, this should return 
		//         true.
		//
		
		expected.setRow(new MappingSpecification(new String[] {"James Howlett" }, new String[] { "Wolverine"}));
		expected.setColumn(new MappingSpecification(new String[] {"Ororo Munroe" }, new String[] { "Storm" }));
		expected.setValue(new ValueMapping(new String[] { "Apocalipse" }));
	
		MappingSource actual = expected.clone();
		Assert.assertTrue(expected.equals(actual));
		
		// Test 5. We change a single property, and we check whether that
		//         the method does not return true when we compare again
		//         the two instances.
		
		expected.setValue(new ValueMapping("Magneto"));
		Assert.assertFalse(expected.equals(actual));
		
		// back to previouse state, we now change the row..
		//
		actual.setValue(expected.getValue());
		Assert.assertTrue(expected.equals(actual));
		
		expected.setRow(null);
		Assert.assertFalse(expected.equals(actual));
		
		// back to previous state, we now change the column..
		//
		expected.setRow(actual.getRow());
		expected.setColumn(new MappingSpecification(new String[] { "Charles Xavier" }, new String[] { "Professor X" } ));
		Assert.assertFalse(expected.equals(actual));
		
		
		
	}
}
