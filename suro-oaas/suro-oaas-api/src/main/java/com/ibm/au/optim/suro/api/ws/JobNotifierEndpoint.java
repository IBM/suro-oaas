/**
 * Copyright (C) 2015 IBM Corporation
 * All Rights Reserved
 */
package com.ibm.au.optim.suro.api.ws;

import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.ConcurrentHashMap;

import javax.websocket.CloseReason;
import javax.websocket.EndpointConfig;
import javax.websocket.OnClose;
import javax.websocket.OnMessage;
import javax.websocket.OnOpen;
import javax.websocket.Session;
import javax.websocket.server.ServerEndpoint;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.ibm.au.optim.suro.model.notify.NotificationBus;
import com.ibm.au.optim.suro.model.notify.Notifier;

/**
 * Class <b>JobNotifierEndpoint</b>. This class represents a web-socket endpoint as per <i>JSR-356</i>
 * and it is used to synchronously publish notifications from DOcloud jobs to listening clients. The 
 * current implementation publishes all events from all jobs to all clients that are connected.
 * 
 * TODO Implement job-specific subscriptions to avoid unnecessary traffic from unrelated jobs
 * 
 */
@ServerEndpoint(value = "/ws/job-notifier", configurator=EnvironmentInjectorConfig.class)
public class JobNotifierEndpoint extends EnvironmentEndpoint {

	/**
	 * A {@link Logger} instance that is used to collect and record into a centrl logging
	 * system all the messages generated by instances of this class.
	 */
	private static final Logger LOGGER = LoggerFactory.getLogger(JobNotifierEndpoint.class);

	/**
	 * Notifier adapters currently being tracked by the Web Socket endpoint. For each of the
	 * sessions that are open against this endpoint a {@link Notifier} implementation si used
	 * to forward the messages that are extracted by parsing the logs of remove optimization
	 * strategy executions.
	 */
	private static final Map<Session, Notifier> adapters = new ConcurrentHashMap<>();

	/**
	 * Notification bus singleton instance
	 */
	private final NotificationBus notifierBus = NotificationBus.getInstance();

	/**
	 * Handle new client connecting to the endpoint. This method creates an instance of {@link 
	 * WebSocketNotifierAdapter} which will relay any message that has been published through
	 * the {@link NotificationBus} onto the web socket connection. The adapter is then mapped
	 * to the session passed as argument so that it can be removed once the session is closed.
	 * 
	 * @param session	a {@link Session} containing the information about the connection client
	 * 					socket.
	 * @param config	a {@link EndpointConfig} implementation that can be used to further
	 * 					configure the endpoint. This should be of type {@link EnvironmentInjectorConfig}.
	 */
	@OnOpen
	@Override
	public void onOpen(Session session, EndpointConfig config) {
		super.onOpen(session, config);
		
		Notifier adapter = new WebSocketNotifierAdapter(session);
		notifierBus.subscribe(adapter);
		adapters.put(session, adapter);
		LOGGER.info(String.format("[%s] WS Connected", session.getId()));
	}
	
	/**
	 * This is the method that is used to respond to the web socket client messages. The method
	 * implements a simple response to the <i>ping</i> message. This is to comply with the basic
	 * heart-bet protocol that ensures that the web socket on the server side is alive.
	 * 
	 * @param message	a {@link String} representing the message sent by the client.
	 * @param session	a {@link Session} containing the information about the connection to the
	 * 					web client socket.
	 * 
	 * @return	a {@link String} representing the response message sent to the client.
	 */
	@Override
	@OnMessage
	public String onMessage(String message, Session session) {
		
		return super.onMessage(message, session);
	}


	/**
	 * Handle disconnection of a client session from the endpoint. This method retrieves the {@link Notifier} 
	 * implementation that is mapped to the session being closed, unsubscribes it from the {@link NotificationBus}
	 * and also opportunistically scans the list of currently mapped {@link Notifier} implementations and check
	 * whether there are instances that need to be removed.
	 * 
	 * 
	 * @param session	a {@link Session} containing the information about the connection to the
	 * 					web client socket that is closing the connection.
	 * @param closeReason	a {@link CloseReason} instance encapsulating the reason why the connection
	 * 					is closed.
	 */
	@OnClose
	@Override
	public void onClose(Session session, CloseReason closeReason) {
		
		try {
			
			Notifier notifier = adapters.remove(session);
			if (notifier != null) {
				notifierBus.unsubscribe(notifier);
			}
			LOGGER.info(String.format("[%s] WS Disconnected [Reason: %s]", session.getId(), closeReason));
			this.cleanup();
		
		} finally {
			
			super.onClose(session, closeReason);
		}
	}
	/**
	 * This method scans the list of {@link Notifier} implementation used to relay onto the active
	 * web socket connections the messages parsed from the log received by the remote optimization
	 * API and checks whether any of them does not have a connected client. If that is the case the
	 * corresponding notifier is removed from the list and unsubscribed from the bus.
	 */
	private void cleanup() {
		
		for (Entry<Session, Notifier> entry : adapters.entrySet()) {
			
			if (!entry.getKey().isOpen()) {
				
				notifierBus.unsubscribe(entry.getValue());
				adapters.get(entry.getKey());
			}
		}
	}
}
